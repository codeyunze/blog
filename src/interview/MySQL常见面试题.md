---
icon: fa-solid fa-database
date: 2024-09-02
order: 15
categories:
   - 数据库
tags:
   - MySQL
---

MySQL数据库在面试过程中，常常会被问到问题有索引结构、性能调优、分库分表、锁。

<!-- more -->

# MySQL常见的面试题

## 1. MySQL的索引是什么？

索引是针对数据表里某个字段或某些字段，做好排序的数据结构。

## 2. 聚集（聚簇）索引和非聚集（非聚簇）索引是什么？

聚集索引是索引结构里的叶子节点带了数据信息，就是表数据的一整行数据，索引和数据在同一个 `.idb` 文件里。

非聚集索引是索引和数据分离的，索引在 `.myi` 文件里，数据文件在 `.myd` 文件里。

## 3. MySQL的锁有哪些？

此处简单介绍下MySQL在各种类型场景下的锁，如需详细了解，可以看文章 《  [MySQL有哪些锁](../database/mysql/MySQL有哪些锁.md)  》。

### 3.1 按照锁的粒度划分

#### **行锁**

是最低粒度的的锁，锁住指定行的数据，加锁的开销较大，加锁较慢，可能会出现死锁的情况，锁的竞争度会较低，并发度相对较高。但是如果where条件里的字段没有加索引，则加的行锁会自动升级为表锁，因为行锁是基于索引去进行操作的，所以想要加行锁，就一定要在条件字段为索引的基础上进行操作。

#### **表锁**

锁住指定的表，粒度较大，但是加锁的开销小，加锁快，不会出现死锁，且锁的竞争度会较为激烈，并发度比行锁要低很多。

#### 全局锁

粒度最大的锁，会锁住整个库，所有的表都不能进行更新插入操作，只能读。

### **3.2 按照互斥性划分**

#### **共享锁（读锁）**

一个事务给某行数据加上共享锁之后，其他事务就不能再加拍排他锁，但是可以加共享锁。

#### **排他锁（写锁）**

一个事务给某行数据加上排他锁之后，其他事务就不能再给这行数据加任何锁，即不允许写，也不允许读。

### **3.3 按照性能划分**

> 注意：乐观锁、悲观锁、意向锁都不是mysql里实际上真正的锁，而是由开发人员定义出来区分两种类型锁的设计思想。



#### **悲观锁（PCC）**

悲观锁（Pessimistic Concurrency Control）的思想是，持有一种很悲观消极的态度，默认为在数据资源被外部访问时，一定会出现冲突，所以在一个线程在数据处理的过程中都会持有锁资源，保证在同一时刻，只有一个线程可以访问到这个数据，具有排他性。

一般悲观锁都是直接使用mysql数据库的行锁和表锁去实现。



#### **乐观锁（OCC）**

乐观锁（Optimistic Concurrency Control）的思想是，持有一种乐观的态度，认为即使是在并发的场景下，对于数据资源的访问，也不会出现冲突，所以不会去加锁，而是在数据进行提交更新操作的时候，才会去判断此次提交是否存在冲突，如果冲突了，便在代码逻辑层面去处理冲突之后的处理方案，是直接结束本次更新操作，还是重新再去尝试更新。



#### **间隙锁（Gap-Lock）**

> 间隙锁是InnoDB在可重复读的隔离级别下，为了解决幻读而引入的一种锁机制。
>
> 间隙锁只会在数据表的隔离级别为可重复读隔离级别下才能生效。

是在索引记录之间的间隙上加的一个锁，是锁定了一个数据区间，比如一数据表的字段a数据为[1, 2, 5, 9]，如果sql如下

```sql
select * from tablename where a = 3 for update;
```

，则加的间隙锁就是[2, 5]，间隙的范围是根据检索条件向下寻找最靠近检索条件的记录值A，用于作为左区间，向上寻找最靠近检索条件的记录值B，用于作为右区间，即锁定的间隙为（A，B）。加上了间隙锁，则[2, 5]区间的数据都不能再进行操作，直到锁释放。
