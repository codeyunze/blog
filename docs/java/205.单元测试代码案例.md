---
title: Spring Boot + Spring Cloud + MyBatis Plus 单元测试指南
createTime: 2025/06/27 14:18:42
permalink: /article/wgx8jehh/
---

本文将详细介绍如何在 Spring Boot + Spring Cloud + MyBatis Plus 项目中为 DAO 层、Service 层和 Controller 层编写单元测试，并提供完整的测试案例。

<!-- more -->

## 一、单元测试环境搭建

### 1. 依赖配置

在 `pom.xml` 中添加测试相关依赖：

```xml
<dependencies>
    <!-- Spring Boot 测试支持 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- MyBatis Plus 测试支持 -->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter-test</artifactId>
        <version>最新版本</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Mockito 用于模拟对象 -->
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-core</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- 断言库 -->
    <dependency>
        <groupId>org.assertj</groupId>
        <artifactId>assertj-core</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### 2. 测试基类

创建测试基类，配置公共测试环境：

```java
@SpringBootTest
@RunWith(SpringRunner.class)
@ActiveProfiles("test")
public abstract class BaseTest {
    // 公共测试配置
}
```

## 二、DAO 层单元测试

### 1. 测试目标

- 验证 MyBatis Plus Mapper 接口的基本 CRUD 操作
- 测试自定义 SQL 查询
- 验证分页查询功能

### 2. 测试案例

```java
public class UserMapperTest extends BaseTest {
    
    @Autowired
    private UserMapper userMapper;
    
    @Test
    @Transactional
    @Rollback
    public void testInsert() {
        User user = new User();
        user.setUsername("testUser");
        user.setPassword("123456");
        user.setEmail("test@example.com");
        
        int result = userMapper.insert(user);
        assertThat(result).isEqualTo(1);
        assertThat(user.getId()).isNotNull();
    }
    
    @Test
    public void testSelectById() {
        User user = userMapper.selectById(1L);
        assertThat(user).isNotNull();
        assertThat(user.getUsername()).isEqualTo("admin");
    }
    
    @Test
    @Transactional
    @Rollback
    public void testUpdate() {
        User user = userMapper.selectById(1L);
        user.setEmail("new@example.com");
        
        int result = userMapper.updateById(user);
        assertThat(result).isEqualTo(1);
        
        User updatedUser = userMapper.selectById(1L);
        assertThat(updatedUser.getEmail()).isEqualTo("new@example.com");
    }
    
    @Test
    @Transactional
    @Rollback
    public void testDelete() {
        int result = userMapper.deleteById(2L);
        assertThat(result).isEqualTo(1);
        
        User deletedUser = userMapper.selectById(2L);
        assertThat(deletedUser).isNull();
    }
    
    @Test
    public void testSelectByPage() {
        Page<User> page = new Page<>(1, 10);
        IPage<User> userPage = userMapper.selectPage(page, null);
        
        assertThat(userPage.getRecords()).isNotEmpty();
        assertThat(userPage.getTotal()).isGreaterThan(0);
    }
}
```

### 3. 测试要点

1. 使用 `@Transactional` 和 `@Rollback` 注解确保测试数据不会污染数据库
2. 每个测试方法应专注于测试一个功能点
3. 验证返回值和数据库状态变化
4. 对于复杂查询，验证查询条件和返回结果

## 三、Service 层单元测试

### 1. 测试目标

- 验证业务逻辑正确性
- 测试事务管理
- 验证异常处理
- 测试服务间调用

### 2. 测试案例

```java
@RunWith(MockitoJUnitRunner.class)
public class UserServiceTest {
    
    @Mock
    private UserMapper userMapper;
    
    @Mock
    private RoleService roleService;
    
    @InjectMocks
    private UserServiceImpl userService;
    
    @Test
    public void testRegisterUser_Success() {
        // 准备测试数据
        UserDTO userDTO = new UserDTO();
        userDTO.setUsername("newUser");
        userDTO.setPassword("123456");
        userDTO.setEmail("new@example.com");
        
        // 模拟依赖行为
        when(userMapper.selectOne(any(QueryWrapper.class))).thenReturn(null);
        when(userMapper.insert(any(User.class))).thenReturn(1);
        when(roleService.assignDefaultRole(anyLong())).thenReturn(true);
        
        // 调用测试方法
        Result<UserVO> result = userService.registerUser(userDTO);
        
        // 验证结果
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getData().getUsername()).isEqualTo("newUser");
        
        // 验证交互
        verify(userMapper).selectOne(any(QueryWrapper.class));
        verify(userMapper).insert(any(User.class));
        verify(roleService).assignDefaultRole(anyLong());
    }
    
    @Test
    public void testRegisterUser_UsernameExists() {
        // 准备测试数据
        UserDTO userDTO = new UserDTO();
        userDTO.setUsername("existingUser");
        userDTO.setPassword("123456");
        
        // 模拟用户名已存在
        User existingUser = new User();
        existingUser.setUsername("existingUser");
        when(userMapper.selectOne(any(QueryWrapper.class))).thenReturn(existingUser);
        
        // 调用并验证异常
        assertThatThrownBy(() -> userService.registerUser(userDTO))
            .isInstanceOf(BusinessException.class)
            .hasMessage("用户名已存在");
    }
    
    @Test
    public void testUpdateUserProfile() {
        // 准备测试数据
        Long userId = 1L;
        UserProfileDTO profileDTO = new UserProfileDTO();
        profileDTO.setNickname("新昵称");
        profileDTO.setAvatar("new_avatar.jpg");
        
        User user = new User();
        user.setId(userId);
        user.setUsername("testUser");
        
        // 模拟依赖行为
        when(userMapper.selectById(userId)).thenReturn(user);
        when(userMapper.updateById(any(User.class))).thenReturn(1);
        
        // 调用测试方法
        Result<Void> result = userService.updateUserProfile(userId, profileDTO);
        
        // 验证结果
        assertThat(result.isSuccess()).isTrue();
        assertThat(user.getNickname()).isEqualTo("新昵称");
        assertThat(user.getAvatar()).isEqualTo("new_avatar.jpg");
    }
}
```

### 3. 测试要点

1. 使用 Mockito 模拟依赖组件
2. 测试正常流程和异常流程
3. 验证业务逻辑正确性和事务行为
4. 测试服务间的交互
5. 验证权限控制和参数校验

## 四、Controller 层单元测试

### 1. 测试目标

- 验证 API 接口的正确性
- 测试请求参数绑定和验证
- 验证响应格式和状态码
- 测试权限控制和异常处理

### 2. 测试案例

```java
@RunWith(SpringRunner.class)
@WebMvcTest(UserController.class)
@Import({SecurityConfig.class, ExceptionHandlerConfig.class})
public class UserControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private UserService userService;
    
    @Test
    @WithMockUser(username = "admin", roles = "ADMIN")
    public void testGetUserById() throws Exception {
        // 准备模拟数据
        UserVO userVO = new UserVO();
        userVO.setId(1L);
        userVO.setUsername("testUser");
        userVO.setEmail("test@example.com");
        
        when(userService.getUserById(1L)).thenReturn(Result.success(userVO));
        
        // 发起请求并验证
        mockMvc.perform(get("/api/users/1")
                .contentType(MediaType.APPLICATION_JSON))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.username").value("testUser"))
            .andExpect(jsonPath("$.data.email").value("test@example.com"));
    }
    
    @Test
    @WithMockUser(username = "admin", roles = "ADMIN")
    public void testCreateUser_Success() throws Exception {
        // 准备请求数据
        UserDTO userDTO = new UserDTO();
        userDTO.setUsername("newUser");
        userDTO.setPassword("Password123");
        userDTO.setEmail("new@example.com");
        
        UserVO userVO = new UserVO();
        userVO.setUsername("newUser");
        userVO.setEmail("new@example.com");
        
        when(userService.registerUser(any(UserDTO.class)))
            .thenReturn(Result.success(userVO));
        
        // 发起请求并验证
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(JsonUtils.toJson(userDTO)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.data.username").value("newUser"));
    }
    
    @Test
    @WithMockUser(username = "admin", roles = "ADMIN")
    public void testCreateUser_InvalidInput() throws Exception {
        // 准备无效的请求数据
        UserDTO userDTO = new UserDTO();
        userDTO.setUsername("a");  // 用户名太短
        userDTO.setPassword("123");  // 密码太简单
        
        // 发起请求并验证
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(JsonUtils.toJson(userDTO)))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.code").value(400))
            .andExpect(jsonPath("$.message").value("参数校验失败"));
    }
    
    @Test
    public void testGetUserById_Unauthorized() throws Exception {
        // 未授权访问
        mockMvc.perform(get("/api/users/1"))
            .andExpect(status().isUnauthorized());
    }
}
```

### 3. 测试要点

1. 使用 `@WebMvcTest` 专注于 Web 层测试
2. 使用 `MockMvc` 模拟 HTTP 请求
3. 测试各种 HTTP 方法和状态码
4. 验证请求参数绑定和校验
5. 测试安全控制和权限验证
6. 验证异常处理和错误响应格式

## 五、单元测试最佳实践

### 1. 测试命名规范

- 测试类名：`被测类名 + Test`，如 `UserServiceTest`
- 测试方法名：`test + 被测方法名 + 测试场景`，如 `testRegisterUser_UsernameExists`

### 2. 测试结构

遵循 **Given-When-Then** 模式：

```java
@Test
public void testMethodName_Scenario() {
    // Given - 准备测试数据和模拟行为
    User user = new User();
    user.setUsername("test");
    when(userRepository.save(any(User.class))).thenReturn(user);
    
    // When - 调用被测方法
    User result = userService.createUser(user);
    
    // Then - 验证结果和交互
    assertThat(result.getUsername()).isEqualTo("test");
    verify(userRepository).save(any(User.class));
}
```

### 3. 断言选择

优先使用 AssertJ 提供的丰富断言：

```java
import static org.assertj.core.api.Assertions.*;

// 对象断言
assertThat(user).isNotNull();
assertThat(user.getName()).isEqualTo("test");

// 集合断言
assertThat(userList).hasSize(3).extracting("name").contains("Alice", "Bob");

// 异常断言
assertThatThrownBy(() -> service.method(null))
    .isInstanceOf(IllegalArgumentException.class)
    .hasMessage("参数不能为空");
```

### 4. 测试覆盖率

使用 Jacoco 检查测试覆盖率：

```xml
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.7</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

执行测试并生成报告：

```bash
mvn clean test jacoco:report
```

## 六、常见问题解决方案

### 1. 如何测试事务回滚？

```java
@Test
@Transactional
public void testTransactionalMethod() {
    // 测试方法会在事务中执行，默认回滚
    service.transactionalOperation();
    
    // 验证数据库状态
    assertThat(repository.count()).isEqualTo(0);
}

// 需要提交事务的情况
@Test
@Transactional
@Commit
public void testWithCommit() {
    // 测试数据会被提交到数据库
}
```

### 2. 如何模拟 Feign 客户端？

```java
@SpringBootTest
@AutoConfigureMockMvc
public class OrderControllerTest {
    
    @MockBean
    private UserServiceClient userServiceClient;
    
    @Test
    public void testGetOrderWithUser() throws Exception {
        // 模拟 Feign 客户端响应
        when(userServiceClient.getUser(anyLong()))
            .thenReturn(new UserVO(1L, "testUser"));
        
        mockMvc.perform(get("/orders/1"))
            .andExpect(jsonPath("$.userName").value("testUser"));
    }
}
```

### 3. 如何测试多线程业务逻辑？

```java
@Test
public void testConcurrentOperation() throws InterruptedException {
    int threadCount = 10;
    CountDownLatch latch = new CountDownLatch(threadCount);
    
    for (int i = 0; i < threadCount; i++) {
        new Thread(() -> {
            try {
                service.concurrentOperation();
            } finally {
                latch.countDown();
            }
        }).start();
    }
    
    latch.await(5, TimeUnit.SECONDS);
    assertThat(service.getCounter()).isEqualTo(threadCount);
}
```

## 七、总结

本文详细介绍了 Spring Boot + Spring Cloud + MyBatis Plus 项目中各层的单元测试方法：

1. **DAO 层**：直接测试数据库操作，验证 SQL 和 MyBatis Plus 功能
2. **Service 层**：使用 Mockito 模拟依赖，专注于业务逻辑测试
3. **Controller 层**：使用 MockMvc 测试 HTTP 接口，验证请求响应流程

通过遵循这些测试实践，可以显著提高代码质量，减少生产环境中的错误。记住：

- 保持测试独立性和可重复性
- 追求合理的测试覆盖率（建议70%以上）
- 将单元测试作为开发流程的必要环节
- 定期维护测试代码，保持与生产代码同步