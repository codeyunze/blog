---
title: Redis基础数据结构
createTime: 2025/08/20 22:42:04
permalink: /interview/p922acfw/
tags:
  - 手册
  - redis
---



## 查看帮助命令

```cmd
help @string
help @hash
help @stream
...
```



## 1. String (字符串)

最基础的字符串类型，可以存储文本、数字或二进制数据，适合简单的键值对数据（几乎万能）。

| 命令                           | 描述                                                         | 示例                            |
| :----------------------------- | :----------------------------------------------------------- | :------------------------------ |
| `SET key value`                | 设置指定 key 的值                                            | `SET name "John"`               |
| `GET key`                      | 获取指定 key 的值                                            | `GET name`                      |
| `MSET key1 value1 key2 value2` | 同时设置一个或多个 key-value 对                              | `MSET a 1 b 2`                  |
| `MGET key1 key2`               | 获取所有(一个或多个)给定 key 的值                            | `MGET a b`                      |
| `SETEX key seconds value`      | 设置值并同时设置过期时间（秒）                               | `SETEX session:123 3600 "data"` |
| `SETNX key value`              | 只有在 key 不存在时设置 key 的值（用于锁）                   | `SETNX lock:resource 1`         |
| `INCR key`                     | 将 key 中储存的数字值增一（原子操作）                        | `INCR views`                    |
| `INCRBY key increment`         | 将 key 所储存的值加上给定的增量值                            | `INCRBY inventory -5`           |
| `DECR key`                     | 将 key 中储存的数字值减一                                    | `DECR stock`                    |
| `APPEND key value`             | 如果 key 已经存在并且是一个字符串，将 value 追加到末尾       | `APPEND msg " World"`           |
| `GETRANGE key start end`       | 返回 key 中字符串值的子字符<br />start为从第几个字符开始，<br />end为截取到第几个字符 | `GETRANGE name 0 2` -> "Joh"    |
| `STRLEN key`                   | 返回 key 所储存的字符串值的长度                              | `STRLEN name`                   |

---

## 2. Hash (哈希)

类似于 Map，适合存储对象。

用于存储一组键值对数据，这一组键值对数据组合成一个实体对象数据，例如用户信息、配置参数。

| 命令                                    | 描述                                         | 示例                                 |
| :-------------------------------------- | :------------------------------------------- | :----------------------------------- |
| `HSET key field value`                  | 将哈希表 key 中的字段 field 的值设为 value   | `HSET user:1000 name "Alice" age 30` |
| `HGET key field`                        | 获取存储在哈希表中指定字段的值               | `HGET user:1000 name`                |
| `HGETALL key`                           | 获取在哈希表中指定 key 的所有字段和值        | `HGETALL user:1000`                  |
| `HMSET key field1 value1 field2 value2` | 同时将多个 field-value 对设置到哈希表 key 中 | `HMSET user:1001 name "Bob" age 25`  |
| `HMGET key field1 field2`               | 获取所有给定字段的值                         | `HMGET user:1000 name age`           |
| `HDEL key field1 field2`                | 删除一个或多个哈希表字段                     | `HDEL user:1000 age`                 |
| `HKEYS key`                             | 获取哈希表中的所有字段名                     | `HKEYS user:1000`                    |
| `HVALS key`                             | 获取哈希表中的所有值                         | `HVALS user:1000`                    |
| `HINCRBY key field increment`           | 为哈希表 key 中的指定字段的整数值加上增量    | `HINCRBY user:1000 score 5`          |
| `HEXISTS key field`                     | 查看哈希表 key 中，指定的字段是否存在        | `HEXISTS user:1000 name`             |
| `HLEN key`                              | 获取哈希表中字段的数量                       | `HLEN user:1000`                     |

---

## 3. List (列表)

简单的字符串列表，按插入顺序排序，可在两端操作。（列表，有序，底层数据结构是双向联表）

适合存储队列数据，例如消息队列、任务队列等

| 命令                      | 描述                                                         | 示例                          |
| :------------------------ | :----------------------------------------------------------- | :---------------------------- |
| `LPUSH key value1 value2` | 将一个或多个值插入到列表**头部**（左边）                     | `LPUSH tasks "task1" "task2"` |
| `RPUSH key value1 value2` | 将一个或多个值插入到列表**尾部**（右边）                     | `RPUSH tasks "task3"`         |
| `LPOP key`                | 移除并获取列表的**第一个**元素（左边）                       | `LPOP tasks` -> "task2"       |
| `RPOP key`                | 移除并获取列表的**最后一个**元素（右边）                     | `RPOP tasks` -> "task3"       |
| `LRANGE key start stop`   | 获取列表指定范围内的元素（0 到 -1 表示全部）                 | `LRANGE tasks 0 -1`           |
| `LLEN key`                | 获取列表长度                                                 | `LLEN tasks`                  |
| `LINDEX key index`        | 通过索引获取列表中的元素                                     | `LINDEX tasks 0`              |
| `LREM key count value`    | 移除列表中与 value 相等的元素（根据 count）                  | `LREM tasks 1 "task1"`        |
| `BRPOP key timeout`       | 移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 | `BRPOP tasks 5`               |

---

## 4. Set (集合)

String 类型的**无序集合**，通过哈希表实现，**元素不重复**。

用于存储唯一的元素集合，适合标签系统、好友列表

| 命令                       | 描述                                     | 示例                             |
| :------------------------- | :--------------------------------------- | :------------------------------- |
| `SADD key member1 member2` | 向集合添加一个或多个成员                 | `SADD tags "redis" "db" "cache"` |
| `SMEMBERS key`             | 返回集合中的所有成员                     | `SMEMBERS tags`                  |
| `SISMEMBER key member`     | 判断 member 元素是否是集合 key 的成员    | `SISMEMBER tags "redis"`         |
| `SREM key member1 member2` | 移除集合中一个或多个成员                 | `SREM tags "db"`                 |
| `SCARD key`                | 获取集合的成员数                         | `SCARD tags`                     |
| `SINTER key1 key2`         | 返回给定所有集合的**交集**               | `SINTER group:A group:B`         |
| `SUNION key1 key2`         | 返回给定所有集合的**并集**               | `SUNION group:A group:B`         |
| `SDIFF key1 key2`          | 返回给定所有集合的**差集** (key1 - key2) | `SDIFF group:A group:B`          |
| `SPOP key`                 | 随机移除并返回集合中的一个元素           | `SPOP tags`                      |

---

## 5. Sorted Set (有序集合 ZSet)

Set 的升级版，每个成员都关联一个 `score`（分数），用于排序。**元素不重复，但 score 可以重复**。

适合排行榜、事件轴等需要排序，且元素唯一的集合。

| 命令                                     | 描述                                                   | 示例                                          |
| :--------------------------------------- | :----------------------------------------------------- | :-------------------------------------------- |
| `ZADD key score1 member1 score2 member2` | 向有序集合添加一个或多个成员，或者更新已存在成员的分数 | `ZADD leaderboard 100 "player1" 90 "player2"` |
| `ZRANGE key start stop [WITHSCORES]`     | 通过索引区间返回有序集合指定区间内的成员（低到高）     | `ZRANGE leaderboard 0 -1 WITHSCORES`          |
| `ZREVRANGE key start stop [WITHSCORES]`  | 返回有序集中指定区间内的成员，通过索引，分数从高到低   | `ZREVRANGE leaderboard 0 2 WITHSCORES`        |
| `ZRANGEBYSCORE key min max [WITHSCORES]` | 通过分数返回有序集合指定区间内的成员                   | `ZRANGEBYSCORE leaderboard 90 100`            |
| `ZINCRBY key increment member`           | 增加有序集合中成员的分数                               | `ZINCRBY leaderboard 15 "player1"`            |
| `ZRANK key member`                       | 返回有序集合中指定成员的**排名**（低到高，从0开始）    | `ZRANK leaderboard "player2"`                 |
| `ZREVRANK key member`                    | 返回有序集合中指定成员的排名（高到低）                 | `ZREVRANK leaderboard "player1"`              |
| `ZSCORE key member`                      | 返回有序集中，成员的分数值                             | `ZSCORE leaderboard "player1"`                |
| `ZREM key member1 member2`               | 移除有序集合中的一个或多个成员                         | `ZREM leaderboard "player2"`                  |
| `ZCARD key`                              | 获取有序集合的成员数                                   | `ZCARD leaderboard`                           |

---

## 6. Bitmap (位图)

通过 String 类型衍生的位操作，非常节省空间，用于二值统计（是/否）。

可用于统计用户每天签到情况。

| 命令                                | 描述                                                         | 示例                                              |
| :---------------------------------- | :----------------------------------------------------------- | :------------------------------------------------ |
| `SETBIT key offset value`           | 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit) (0/1) | `SETBIT user:sign:202410 5 1` (用户10月5日签到)   |
| `GETBIT key offset`                 | 对 key 所储存的字符串值，获取指定偏移量上的位(bit)           | `GETBIT user:sign:202410 5` (查询10月5日是否签到) |
| `BITCOUNT key`                      | 计算给定字符串中，被设置为 1 的比特位的数量                  | `BITCOUNT user:sign:202410` (统计10月签到次数)    |
| `BITPOS key bit`                    | 返回位图中第一个设置为指定值 `bit` 的二进制位的位置          | `BITPOS user:sign:202410 1`                       |
| `BITOP operation destkey key1 key2` | 对一个或多个位图执行逻辑操作(AND/OR/XOR/NOT)并将结果存到 destkey | `BITOP AND result key1 key2`                      |

---

## 7. HyperLogLog

用于做**基数统计**（估算集合中不重复元素的个数），优点是非常省内存。

例如：统计不重复IP数据量，统计UV(独立访客数量)、活跃用户情况场景，非常节省内存，只需要12K的空间就可以存储近2^64个不同的元素

| 命令                                    | 描述                                                  | 示例                                                 |
| :-------------------------------------- | :---------------------------------------------------- | :--------------------------------------------------- |
| `PFADD key element1 element2`           | 添加指定元素到 HyperLogLog 中                         | `PFADD visitors:day1 "user1" "user2" "user3"`        |
| `PFCOUNT key1 key2`                     | 返回给定 HyperLogLog 的基数估算值（去重后的元素个数） | `PFCOUNT visitors:day1`                              |
| `PFMERGE destkey sourcekey1 sourcekey2` | 将多个 HyperLogLog 合并为一个                         | `PFMERGE visitors:total visitors:day1 visitors:day2` |

---

## 8. Geo (地理空间)

用于存储地理位置信息，并进行计算（如计算两地距离）。

坐标距离，范围计算。

| 命令                                           | 描述                                                      | 示例                                           |
| :--------------------------------------------- | :-------------------------------------------------------- | :--------------------------------------------- |
| `GEOADD key longitude latitude member`         | 将指定的地理空间位置（纬度、经度、名称）添加到指定的key中 | `GEOADD cities 116.405285 39.904999 "Beijing"` |
| `GEOPOS key member1 member2`                   | 从key里返回所有给定位置元素的位置（经度和纬度）           | `GEOPOS cities "Beijing"`                      |
| `GEODIST key member1 member2 [unit]`           | 返回两个给定位置之间的距离(m米/km千米/mi英里/ft英尺)      | `GEODIST cities "Beijing" "Shanghai" km`       |
| `GEORADIUS key longitude latitude radius unit` | 以给定的经纬度为中心，找出某一半径内的元素                | `GEORADIUS cities 116.40 39.90 100 km`         |
| `GEOHASH key member1 member2`                  | 返回一个或多个位置元素的 Geohash 表示                     | `GEOHASH cities "Beijing"`                     |

---

## 9. Stream

主要用于消息队列（MQ），提供消息的持久化、消费者组等功能。

> key必须是递增的。

| 命令                                                        | 描述                                                       | 示例                                                         |
| :---------------------------------------------------------- | :--------------------------------------------------------- | :----------------------------------------------------------- |
| `XADD key * field1 value1 field2 value2`                    | 添加消息到Stream末尾（`*` 表示让Redis自动生成唯一ID）      | `XADD mystream * sensor-id 1234 temp 19.8`                   |
| `XLEN key`                                                  | 获取Stream中的消息数量                                     | `XLEN mystream`                                              |
| `XREAD COUNT n STREAMS key id`                              | 从一个或多个Stream中读取消息（从指定ID开始）               | `XREAD COUNT 2 STREAMS mystream 0` (从开头读)                |
| `XREAD BLOCK ms STREAMS key $`                              | 阻塞读取新消息（`$` 表示只读取最新的消息）                 | `XREAD BLOCK 5000 STREAMS mystream $`                        |
| `XRANGE key start end [COUNT n]`                            | 根据消息ID范围查询消息                                     | `XRANGE mystream - + COUNT 5`                                |
| `XGROUP CREATE key groupname id`                            | 创建一个消费者组                                           | `XGROUP CREATE mystream mygroup $`                           |
| `XREADGROUP GROUP groupname consumer COUNT n STREAMS key >` | 消费者组内的消费者读取消息（`>` 表示从未交付的消息开始读） | `XREADGROUP GROUP mygroup consumerA COUNT 1 STREAMS mystream >` |
| `XACK key groupname id`                                     | 将消息标记为"已处理"                                       | `XACK mystream mygroup 1643677896543-0`                      |

