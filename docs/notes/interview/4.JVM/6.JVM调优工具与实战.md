## Jmap

### 1. 查看内存里对象实例信息

可以用来查看内存信息，实例个数以及占用内存大小。

```bash
# 先使用jps命令查询出应用的进程ID
# 然后使用jmap查看内存信息
jmap -histo <PID> > ./memory-log.txt
```

![image-20250929140033011](images/image-20250929140033011.png)

展示数据说明

1. num（序号）

2. instances（实例数量）

3. bytes（占用空间大小）

4. class name（类名称）

   [C 是一个 char 数组

   [S 是一个 short 数组

   [[I 是一个 int 数组

   [[B 是一个 byte 数组

   [[I 是一个 int 二位数组



### 2. 查看堆内存信息

```bash
jmap -heap <PID>
```



![image-20250929140719076](images/image-20250929140719076.png)

参数解读

**堆内存配置信息 Heap Configuration**

| 参数                     | 值       | 说明                           |
| ------------------------ | -------- | ------------------------------ |
| `MaxHeapSize`            | 2048.0MB | 堆最大 2GB                     |
| `NewSize` / `MaxNewSize` | 768.0MB  | 年轻代固定大小（-Xmn768m）     |
| `OldSize`                | 1280.0MB | 老年代大小                     |
| `NewRatio`               | 2        | 老年代 : 年轻代 = 2:1          |
| `SurvivorRatio`          | 8        | Eden : From : To = 8:1:1       |
| `MaxMetaspaceSize`       | 256.0MB  | 元空间最大 256MB（已设置限制） |

**堆内存使用情况 Heap Usage**

#### 年轻代+首尔区 

New Generation (Eden + 1 Survivor Space)

- **总容量** 为 691.25 MB
- **已使用** 为 404.09 MB（**58.5%**）
- **Eden 区使用率** 为 54.6%
- **From Survivor 使用率** 为 89.2%
- **To Survivor** 为 空

#### 老年代

CMS垃圾收集器 concurrent mark-sweep generation

- **总容量**：1280.0 MB
- **已使用**：236.79 MB（**18.5%**）



### 3. 堆内存dump

#### 手动dump命令

```bash
jmap -dump:format=b,file=jvm-oom.dump <PID>
```



#### 出现oom自动dump

设置堆内存溢出时自动导出dump文件（内存很大的时候，可能会导不出来），保存系统出现异常时的现场

```bash
‐XX:+HeapDumpOnOutOfMemoryError ‐XX:HeapDumpPath=./jvm-oom.dump
```



这个dump文件加载到 visualVM 工具里可以看内存里类的实例数和大小。

![image-20250929143146955](images/image-20250929143146955.png)



## Jstack

可以用 jstack 加进程id查找死锁

```bash
jstack <PID>
```



### 找出占用cpu最高的线程堆栈信息

1. 使用命令 `top -p <pid>` ，显示你的java进程的内存情况，pid是应用的java进程号

2. 按大写的H，获取每个线程的内存情况
3. 找到内存和cpu占用最高的线程PID
4. 将这个PID转为十六进制得到 0x4cd0，此为线程id的十六进制表示
5. 执行 `jstack 19663 | grep -A 10 4cd0`，得到线程堆栈信息中 4cd0 这个线程所在行的后面10行，从堆栈中可以发现导致cpu飙高的调用方法
6. 查看对应的堆栈信息找出可能存在问题的代码