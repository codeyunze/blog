---
title: Future详解
createTime: 2025/08/20 22:47:30
permalink: /interview/wzcilh93/
---



ThreadLocal的ThreadLocalMap下一个节点的Entry，其中的value设计为强引用而不是弱引用？

思考点，因为其Entry的key为弱引用，所以当业务中使用完ThreadLocal后，ThreadLocal Ref就被回收了，而最后一个引用这个ThreadLocal对象的只有Entry的key，而这个又是弱引用，所以会被回收，当key被回收后，Entry的value又还有什么存在的意义呢？他已经无法被使用了，为什么不设置为弱引用呢？

原因一：value指向的对象数据，本来就只有Entry的value去引用，如果设计为弱引用，那么在业务代码还在使用ThreadLocal的期间，这个value指向的对象就有可能被回收，这是不能容忍的。

原因二：隐式管理和显示管理，弱应用就是将回收的责任交给了gc，垃圾的回收相对不可预测，出现问题不好复现，这是隐式管理。强引用就是将回收操作的责任交给的程序员，使用remove去回收，是可以预测的，出现问题可以通过堆内存排查工具jmap分析。



ThreadLocalMap如果要扩容，就是双倍扩容。

如果hash冲突了，就往后移一个节点。

一个线程一个ThreadLocalMap。
