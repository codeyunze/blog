import{_ as r,e as o,f as t,o as l}from"./app-Cx_oisp2.js";const i={};function a(n,e){return l(),o("div",null,e[0]||(e[0]=[t('<h2 id="读源码的方式" tabindex="-1"><a class="header-anchor" href="#读源码的方式"><span>读源码的方式</span></a></h2><ol><li>带着问题去读源码（先了解这个组件有哪几个核心功能，然后自己思考其中一个核心功能大概会怎么实现，再带着自己的问题去源码中找答案）</li><li>一个组件拆分为一个个小功能点，多读几次，不要一直纠结不懂的地方</li><li>分布总结，结合自己的理解总结一个个功能点的实现。对其中一些扩展功能点尝试验证，写测试代码。</li></ol><h2 id="nameserver启动流程梳理" tabindex="-1"><a class="header-anchor" href="#nameserver启动流程梳理"><span>nameserver启动流程梳理</span></a></h2><ol><li><strong>参数解析</strong>：读取启动命令中的参数（如 <code>-p 9876</code>、<code>-c /path/to/config</code>）来覆盖默认配置。</li><li><strong>网络服务初始化</strong>：创建 <code>remotingServer</code> 实例，用作服务端，供客户端（生产者、消费者）获取Broker信息。创建 <code>remotingClient</code> 实例作为客户端，在集群中请求其他节点服务。</li><li><strong>路由表初始化</strong>：创建 <code>RouteInfoManager</code> 对象，这是 NameServer 的<strong>核心内存数据结构</strong>，用于存储在线的 Broker 信息。它包含以下几个核心 Map： <ul><li><code>topicQueueTable</code>: key: topic名称, value: 该topic的队列信息列表（QueueData）</li><li><code>brokerAddrTable</code>: key: broker名称（clusterName），value: Broker数据（BrokerData），包含所属集群及主从地址映射</li><li><code>clusterAddrTable</code>: key: 集群名称, value: 该集群下所有broker名称的集合</li><li><code>brokerLiveTable</code>: key: broker地址, value: Broker实时信息（BrokerLiveInfo），包括上次心跳时间等</li><li><code>filterServerTable</code>: 过滤服务器信息</li></ul></li><li><strong>定时任务</strong>：启动一个每 10 分钟执行一次的定时任务，检查 <code>brokerLiveTable</code>。如果某个 Broker 的最后心跳时间与当前时间差超过 2 分钟，则认为其已下线，将其从路由表中移除。</li><li><strong>就绪服务</strong>：启动 Netty 服务，开始监听端口，等待客户端连接。</li></ol><h4 id="特点总结" tabindex="-1"><a class="header-anchor" href="#特点总结"><span>特点总结：</span></a></h4><ul><li><strong>轻量级</strong>：几乎不持久化任何数据（所有数据在内存中），重启后数据丢失，依赖 Broker 重新上报。</li><li><strong>最终一致性</strong>：Broker 的路由信息通过心跳机制最终同步到所有 NameServer。</li></ul><h2 id="broker启动过程梳理" tabindex="-1"><a class="header-anchor" href="#broker启动过程梳理"><span>broker启动过程梳理</span></a></h2><h4 id="核心步骤详解" tabindex="-1"><a class="header-anchor" href="#核心步骤详解"><span>核心步骤详解：</span></a></h4><ol><li><p><strong>BrokerController</strong>：所有核心模块资源都在这里，负责协调模块间的工作。在启动类 <code>BrokerStartup</code> 的第一个步骤就是创建 <code>BrokerController</code> ，创建好后就是<code>start</code> 启动 BrokerController。</p></li><li><p><strong>初始化核心模块</strong>：</p><p>创建BrokerController时，在 <code>org.apache.rocketmq.broker.BrokerStartup#buildBrokerController</code> 里可以看到核心的几个配置模块 BrokerConfig、NettyServerConfig、NettyClientConfig、MessageStoreConfig、AuthConfig</p><ul><li><strong>BrokerConfig</strong> ：Broker服务的配置信息</li><li><strong>NettyServerConfig</strong> ：netty服务端配置，使Broker作为服务端，用于接收其他服务的请求</li><li><strong>NettyClientConfig</strong> ：netty客户端配置，使Broker作为客户端端，用于请求其他服务，以及向NameServer注册发送心跳。</li><li><strong>AuthConfig</strong> ：权限相关的配置</li></ul><p>在 <code>org.apache.rocketmq.broker.BrokerController#initialize</code> 会进行 <code>Metadata</code>元数据，也就是topic、queue、consumerOffset的初始化，以及 <code>MessageStore</code> 的初始化和 <code>org.apache.rocketmq.broker.BrokerController#initializeRemotingServer</code></p><ul><li><strong>消息存储模块（MessageStore）</strong>：最复杂的模块，通常使用 <code>DefaultMessageStore</code>。</li><li><strong>远程模块（RemotingServer）</strong>：基于 Netty 实现，负责与 Producer、Consumer 及其他 Broker 通信。同时会<strong>注册一系列处理器（Processor）</strong> 来处理不同类型的请求（如发送消息、拉取消息、查询消息等）。</li><li><strong>客户端管理器（ClientManager）</strong>：管理连接的 Producer 和 Consumer 客户端。</li></ul></li><li><p><strong>向 NameServer 注册</strong>：</p><ul><li>Broker 启动后，会立即<strong>向配置的所有 NameServer 地址发送心跳包</strong>(循环发送)。</li><li>心跳包中包含：BrokerName、ClusterName、BrokerId（0表示Master，&gt;0表示Slave）、Broker地址（IP:Port）以及 Topic 配置信息。</li><li>此后，会定期发送一次心跳，以维持自己在 NameServer 中的“在线”状态。</li></ul></li><li><p><strong>启动定时任务</strong>：</p><ul><li>定时持久化消费进度（Offset）。</li><li>定时删除过期的文件。</li><li>如果是从节点（Slave），定时从 Master 同步消息。</li></ul></li><li><p><strong>就绪服务</strong>：所有模块启动成功后，Broker 开始对外提供服务。</p></li></ol><h4 id="broker-与-nameserver-的交互" tabindex="-1"><a class="header-anchor" href="#broker-与-nameserver-的交互"><span>Broker 与 NameServer 的交互</span></a></h4><ol><li><strong>注册</strong>：Broker 启动时向所有 NameServer 发送注册请求（心跳），NameServer 将其信息更新到 <code>brokerAddrTable</code>, <code>brokerLiveTable</code> 等路由表中。</li><li><strong>心跳维持</strong>：Broker 每隔 30 秒向所有 NameServer 发送一次心跳，NameServer 收到后更新 <code>BrokerLiveInfo</code> 中的 <code>lastUpdateTimestamp</code>。</li><li><strong>下线剔除</strong>：NameServer 的定时任务发现某个 Broker 超过 2 分钟未上报心跳，则判定其下线，并将其从路由表中删除。</li><li><strong>客户端发现</strong>：Producer/Consumer 定时从 NameServer 拉取最新的路由信息，从而知道哪些 Broker 是在线的，Topic 分布在哪些 Broker 上。</li></ol><h2 id="producer发送消息" tabindex="-1"><a class="header-anchor" href="#producer发送消息"><span>Producer发送消息</span></a></h2><p>producer的消息发送分两种情况</p><p>普通消息发送，消息发送完就可以结束。</p><p>事务消息发送，消息发送之后，还需要在事务消息过程中提供事务状态确认的服务，所以需要消息发送者在完成这个事务消息的确认机制后，才可以退出。</p><p>消息的发送主要分为两个步骤：</p><ol><li>start启动Producer，<code>org.apache.rocketmq.client.producer.DefaultMQProducer#start</code><ul><li>实例化客户端服务，<code>org.apache.rocketmq.client.impl.factory.MQClientInstance#start</code>， <code>MQClientAPIImpl</code> 负责请求和响应</li><li>初始化 <code>Topic</code> ，从NameServer服务获取到Topic信息，Topic对应的MessageQueue信息，以及存在Queue的Broker信息。 <code>org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#initTopicRoute</code></li></ul></li><li>send发送消息，<code>org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#sendDefaultImpl</code><ul><li>根据要发送消息的Topic，先从本地获取队列信息，如果没有则去NameServer获取，再存到本地。</li><li>选择一个发送队列，负载均衡的去选择，上一次发送过的、上次发送失败的都不会选择。</li><li>消息发送, 根据Queue可以确定要发送给哪个 <code>Broker</code> 服务<code>org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#sendKernelImpl</code></li></ul></li></ol><blockquote><p>就算 NameServer 挂了一小段时间，Producer依旧可以发送消息，因为Producer会缓存信息到本地，只要能找到Broker，还是可以正常发送消息到Broker的</p></blockquote>',18)]))}const s=r(i,[["render",a],["__file","index.html.vue"]]),d=JSON.parse('{"path":"/interview/z1fu8e0u/","title":"RocketMQ源码解读","lang":"zh-CN","frontmatter":{"title":"RocketMQ源码解读","createTime":"2025/09/24 21:02:03","permalink":"/interview/z1fu8e0u/","description":"读源码的方式 带着问题去读源码（先了解这个组件有哪几个核心功能，然后自己思考其中一个核心功能大概会怎么实现，再带着自己的问题去源码中找答案） 一个组件拆分为一个个小功能点，多读几次，不要一直纠结不懂的地方 分布总结，结合自己的理解总结一个个功能点的实现。对其中一些扩展功能点尝试验证，写测试代码。 nameserver启动流程梳理 参数解析：读取启动命令...","head":[["meta",{"property":"og:url","content":"https://blog.gaohan.asia/interview/z1fu8e0u/"}],["meta",{"property":"og:site_name","content":"云泽汇码"}],["meta",{"property":"og:title","content":"RocketMQ源码解读"}],["meta",{"property":"og:description","content":"读源码的方式 带着问题去读源码（先了解这个组件有哪几个核心功能，然后自己思考其中一个核心功能大概会怎么实现，再带着自己的问题去源码中找答案） 一个组件拆分为一个个小功能点，多读几次，不要一直纠结不懂的地方 分布总结，结合自己的理解总结一个个功能点的实现。对其中一些扩展功能点尝试验证，写测试代码。 nameserver启动流程梳理 参数解析：读取启动命令..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-29T09:44:12.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-29T09:44:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ源码解读\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-29T09:44:12.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":4.76,"words":1428},"git":{"updatedTime":1759139052000,"contributors":[{"name":"yunze","username":"yunze","email":"834363368@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"}]},"autoDesc":true,"filePathRelative":"notes/interview/3.MQ/5.RocketMQ源码解读.md"}');export{s as comp,d as data};
