import{_ as t,e as r,f as o,o as a}from"./app-Cx_oisp2.js";const n="/assets/rabbitmq%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-D_g7oifB.png",s={};function i(p,e){return a(),r("div",null,e[0]||(e[0]=[o('<h2 id="mq消息队列的主要3个用途" tabindex="-1"><a class="header-anchor" href="#mq消息队列的主要3个用途"><span>MQ消息队列的主要3个用途</span></a></h2><h3 id="异步" tabindex="-1"><a class="header-anchor" href="#异步"><span>异步</span></a></h3><p>提高系统的响应速度和吞吐量，发送消息后，无需持续等待消息消费。</p><p>例如：快递员送快递，只需要将快递放到驿站即可，无需一直等待客户过来拿快递，既能让快递员有更多时间送其他的快递，还能让客户在有时间的时候再去拿快递，无需一直等待耗费时间等快递员专门给自己送。</p><h3 id="解耦" tabindex="-1"><a class="header-anchor" href="#解耦"><span>解耦</span></a></h3><p>将一个复杂的系统进行解耦，减少服务之间的依赖，提高系统整体的稳定性和可扩展性。</p><p>例如：订单服务生成订单，还需要去请求库存服务、物流服务、消息服务。有了MQ之后，订单服务生成了订单之后，只需要发送一条消息，然后库存服务、物流服务、消息服务等监听这个消息即可，将整个系统进行了解耦。并且消息消费者的增加，对消息生产者是没有任何影响的。</p><h3 id="削峰" tabindex="-1"><a class="header-anchor" href="#削峰"><span>削峰</span></a></h3><p>RocketMQ 单机即可支持每秒十万级的消息处理能力。他可以将海量请求先接收下来，至于处理，可以慢慢来。</p><p>使后端服务不再直接面对海量请求，而是按照<strong>自己最大的、能承受的处理能力</strong>，匀速地从 RocketMQ 中拉取消息进行处理。</p><h2 id="mq产品比对" tabindex="-1"><a class="header-anchor" href="#mq产品比对"><span>MQ产品比对</span></a></h2><table><thead><tr><th>产品</th><th>优点</th><th>缺点</th><th>适合场景</th></tr></thead><tbody><tr><td>Kafka</td><td>吞吐量非常大</td><td>会丢数据、功能单一</td><td>日志分析、大数据采集</td></tr><tr><td>RabbitMQ</td><td>可靠性高、功能全面</td><td>吞吐量较低，使用的erlang语言</td><td>小规模服务调用</td></tr><tr><td>RocketMQ</td><td>高吞吐、高性能、高可用、功能全面，Java语言开发</td><td>服务加载比较慢</td><td>全场景</td></tr></tbody></table><blockquote><p>在阿里内部，RocketMQ集群每天处理的请求数超过5万亿次，天生就为金融互联网而生。</p></blockquote><p>官网地址：http://rocketmq.apache.org</p><h2 id="rocketmq的核心服务" tabindex="-1"><a class="header-anchor" href="#rocketmq的核心服务"><span>RocketMQ的核心服务</span></a></h2><p>RocketMQ由5个核心服务组成。</p><h3 id="nameserver-服务发现与路由中心" tabindex="-1"><a class="header-anchor" href="#nameserver-服务发现与路由中心"><span>NameServer（服务发现与路由中心）</span></a></h3><p><strong>轻量级的发现与路由中心</strong>，类似于 Nacos或ZooKeeper，但更简单、无状态。</p><ol><li><strong>服务注册</strong>：所有 Broker 启动时都会向所有的 NameServer 注册自己的信息（主题、队列、地址等）。</li><li><strong>路由管理</strong>：为生产者和消费者提供最新的路由信息。客户端（Producer/Consumer）会从 NameServer 查询指定 Topic 的消息应该发送到哪个 Broker 上。</li></ol><blockquote><p><strong>总结：</strong> NameServer 就像一个“电话簿”或“路由器”，告诉客户端应该联系谁。</p></blockquote><h3 id="broker-代理服务" tabindex="-1"><a class="header-anchor" href="#broker-代理服务"><span>Broker（代理服务）</span></a></h3><p><strong>消息存储和传输的核心服务</strong>。</p><p><strong>核心职责</strong>：</p><ol><li><strong>消息存储</strong>：负责将生产者发送的消息持久化地存储到磁盘上。</li><li><strong>消息投递</strong>：负责将消息推送给消费者（Push模式）或等待消费者来拉取（Pull模式）。</li><li><strong>高可用保证</strong>：通过主从架构实现数据冗余。Master 负责处理读写请求，Slave 从 Master 同步数据，在 Master 宕机时提供读服务（并可自动切换为 Master）。</li></ol><blockquote><p><strong>总结：</strong> Broker 就像“邮局”的“分拣中心”和“仓库”，负责接收、存储和分发邮件（消息）。</p></blockquote><h3 id="producer-消息生产者" tabindex="-1"><a class="header-anchor" href="#producer-消息生产者"><span>Producer（消息生产者）</span></a></h3><p><strong>消息的发送方，业务的发起端</strong>。是一个<strong>客户端</strong>，是集成在业务应用程序中的。</p><p><strong>核心职责</strong>：</p><ol><li>创建消息。</li><li>向 <code>NameServer</code> 查询目标 <code>Topic</code> 的路由信息。</li><li>根据负载均衡策略，将消息发送到正确的 Broker 队列中。</li></ol><blockquote><p><strong>总结：</strong> Producer 就像“寄信人”，把写好的信（消息）投递到邮局（Broker）。</p></blockquote><h3 id="consumer-消息消费者" tabindex="-1"><a class="header-anchor" href="#consumer-消息消费者"><span>Consumer（消息消费者）</span></a></h3><p><strong>消息的接收和处理方，业务的消费端</strong>。同样是一个<strong>客户端</strong>，也是集成在业务应用程序中的。</p><p><strong>核心职责</strong>：</p><ol><li>向 <code>NameServer</code> 查询目标 <code>Topic</code> 的路由信息。</li><li>从正确的 <code>Broker</code> 上拉取（Pull）或接收推送（Push）的消息。</li><li>执行具体的业务逻辑处理消息（如：创建订单、发送短信等）。</li><li>向 <code>Broker</code> 返回消费成功（ACK）或失败的状态。</li></ol><blockquote><p>**总结：**Consumer 就像“收信人”，从邮局（Broker）取走属于自己的信（消息）并阅读处理。</p></blockquote><h3 id="dashboard-可视化管理服务" tabindex="-1"><a class="header-anchor" href="#dashboard-可视化管理服务"><span>Dashboard（可视化管理服务）</span></a></h3><p>整个MQ集群的可视化界面与运维管理界面。</p><p><strong>核心职责：</strong></p><ol><li><p><strong>集群状态监控：</strong> 可以查看到所有 NameServer、Broker（Master/Slave）的在线状态、版本信息等。</p></li><li><p><strong>主题（Topic）与消费组（Consumer Group）管理：</strong></p><ul><li>创建、删除、查询 Topic</li><li>查看 Topic 的队列数量、消息堆积情况</li><li>创建、删除、查询消费组</li><li>监控每个消费组的消息消费情况、消费者客户端连接信息</li></ul></li><li><p><strong>消息追踪：</strong> 可以根据 <code>Message ID</code> 或 <code>Message Key</code> 查询消息的轨迹，确认消息是否被发送成功，是被谁消费的，消费是否成功？有利于排查线上问题。</p></li><li><p><strong>消息查询</strong>：可以直接查看队列中的消息内容。</p></li><li><p><strong>运维：</strong> 手动触发消息消费位点重置（比如堆积了大量消息，想从最新位点开始消费）。</p></li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p><img src="'+n+'" alt="rabbitmq服务架构设计"></p>',41)]))}const d=t(s,[["render",i],["__file","index.html.vue"]]),l=JSON.parse('{"path":"/interview/bbnr85ib/","title":"RacketMQ介绍","lang":"zh-CN","frontmatter":{"title":"RacketMQ介绍","createTime":"2025/08/20 22:45:47","permalink":"/interview/bbnr85ib/","description":"MQ消息队列的主要3个用途 异步 提高系统的响应速度和吞吐量，发送消息后，无需持续等待消息消费。 例如：快递员送快递，只需要将快递放到驿站即可，无需一直等待客户过来拿快递，既能让快递员有更多时间送其他的快递，还能让客户在有时间的时候再去拿快递，无需一直等待耗费时间等快递员专门给自己送。 解耦 将一个复杂的系统进行解耦，减少服务之间的依赖，提高系统整体的...","head":[["meta",{"property":"og:url","content":"https://blog.gaohan.asia/interview/bbnr85ib/"}],["meta",{"property":"og:site_name","content":"云泽汇码"}],["meta",{"property":"og:title","content":"RacketMQ介绍"}],["meta",{"property":"og:description","content":"MQ消息队列的主要3个用途 异步 提高系统的响应速度和吞吐量，发送消息后，无需持续等待消息消费。 例如：快递员送快递，只需要将快递放到驿站即可，无需一直等待客户过来拿快递，既能让快递员有更多时间送其他的快递，还能让客户在有时间的时候再去拿快递，无需一直等待耗费时间等快递员专门给自己送。 解耦 将一个复杂的系统进行解耦，减少服务之间的依赖，提高系统整体的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-09T12:05:49.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-09T12:05:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RacketMQ介绍\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-09T12:05:49.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":4.38,"words":1313},"git":{"updatedTime":1757419549000,"contributors":[{"name":"yunze","username":"yunze","email":"834363368@qq.com","commits":3,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"}]},"autoDesc":true,"filePathRelative":"notes/interview/3.MQ/1.RacketMQ介绍.md"}');export{d as comp,l as data};
