import{_ as e,e as d,f as a,o as r}from"./app-Cx_oisp2.js";const o={};function n(p,t){return r(),d("div",null,t[0]||(t[0]=[a('<p>深度解读MySQL意向锁的工作原理机制与应用场景。</p><h1 id="mysql的意向锁" tabindex="-1"><a class="header-anchor" href="#mysql的意向锁"><span>MySQL的意向锁</span></a></h1><h2 id="意向锁的概念" tabindex="-1"><a class="header-anchor" href="#意向锁的概念"><span>意向锁的概念</span></a></h2><blockquote><p>意向锁是InnoDB自动添加的一种锁，不需要用户去干预。</p></blockquote><p>是数据库中的一种表级锁，一个事务要给一个资源加锁时，必须要先获取到对应类型的意向锁之后，才可以给这个资源加上自己想要的共享锁或者排他锁（不论是行级还是表级的共享/排他锁，都是需要先获取到意向共享/排他锁）。</p><p>意向锁并不是真正的锁，而是为了协调事务对表中行的锁定请求而引入的一个概念。</p><h2 id="意向锁业的两个类型" tabindex="-1"><a class="header-anchor" href="#意向锁业的两个类型"><span>意向锁业的两个类型</span></a></h2><p><strong>意向共享锁（Intention Shared Lock，IS锁）:</strong> 表示事务有获取到表的表级或行级共享锁的意向。</p><p><strong>意向排他锁（Intention Exclusive Lock，IX锁）:</strong> 表示事务有获取到表的表级或行级排它锁的意向。</p><blockquote><p>注意：获取意向锁只是表示事务有获取到共享锁和排它锁的意向意图，而不是表示获取了意向锁，就是实际锁定了任何行或表。</p><p>意向锁是互相兼容的，不会互斥。</p></blockquote><h2 id="说明案例" tabindex="-1"><a class="header-anchor" href="#说明案例"><span>说明案例</span></a></h2><p><strong>前提：</strong></p><p>如果事务A需要修改user表的id（有索引）为 &#39;1&#39; 的数据行，则事务A会给这行数据加上一个行级排他锁，和一个意向排他锁。</p><p><strong>场景一：</strong></p><p>此时如果事务B想修改user表的name（无索引）为 &#39;张三&#39; 的数据行，则事务B就需要给user表加上表级排他锁，但是在获取表级排他锁之前，还需要获取意向排他锁，然后就发现已经有事务A获取了意向排他锁，则事务B可以直接阻塞等待了，不再需要往下尝试判断能否获取到表级排他锁。</p><blockquote><p>意向锁通过这种前置判断的操作，很好的解决了行锁与表锁共存时的事务隔离性问题。</p></blockquote><p><strong>场景二：</strong></p><p>此时如果事务B想修改user表的id（有索引）为 <strong>&#39;2&#39;</strong> 的数据行，则事务B就需要先获取意向排他锁，虽然此时事务A已经持有了user表的意向排他锁，但是事务B仍旧可以去获取user表的意向排他锁，因为 <strong><u>意向锁是互相兼容的，不会互相排斥</u></strong> （上文也有说到），获取到意向排他锁之后，再去判断id为2的数据行是否有共享锁和排他锁，发现没有，则事务B持有到user表id为2的数据行的行级排他锁。</p><p><strong>补充说明</strong></p><p>场景一的事务B想要加的是表级排他锁，意味着，只要user表上面有任意一种锁，那么事务B都无法加上表级的排他锁。</p><p>而场景二里的事务B想要加的是行级排他锁，所以，只要事务B想在user表上加锁的那一行数据上面没有锁，那么事务B的行级排他锁就可以加成功。</p><p>场景二里的事务B加行级排他锁时，就算发现了user表已经有其他事务持有了意向排他锁，也会因为事务B要加的是行锁，而进行下一步的判断，判断user表有没有表锁和事务B要操作的那一行数据有没有锁。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>行表头为事务A已经获取的锁</p><p>列表头为事务B能否获取的锁</p><table><thead><tr><th></th><th>意向共享锁</th><th>意向排他锁</th><th>表级共享锁</th><th>表级排他锁</th><th>行级共享锁</th><th>行级排它锁</th></tr></thead><tbody><tr><td>意向共享锁</td><td>兼容</td><td>兼容</td><td>兼容</td><td>不兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td>意向排他锁</td><td>兼容</td><td>兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>表级共享锁</td><td>兼容</td><td>不兼容</td><td>兼容</td><td>不兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td>表级排他锁</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>行级共享锁</td><td>兼容</td><td>额外讨论-1</td><td>兼容</td><td>不兼容</td><td>兼容</td><td>同行不兼容<br>不同行兼容</td></tr><tr><td>行级排它锁</td><td>额外讨论-2</td><td>额外讨论-1</td><td>不兼容</td><td>不兼容</td><td>同行不兼容<br>不同行兼容</td><td>同行不兼容<br>不同行兼容</td></tr></tbody></table><h3 id="额外讨论-1" tabindex="-1"><a class="header-anchor" href="#额外讨论-1"><span>额外讨论-1</span></a></h3><p>事务A获取了 <code>意向排他锁</code> ，事务B能否获取 <code>行级共享锁</code> 或 <code>行级排他锁</code> 需要继续往下去判断，判断事务A的排他锁是表锁还是行锁，</p><p>如果是表锁，则事务B不能再加行级共享锁；</p><p>如果是行锁，则继续判断事务B要加行级共享锁的行是否被事务A或其他事务加了行级排它锁，如果加了，则事务B不能再加行级共享锁，如果这一行没加行级排他锁，则事务B可以加上行级共享锁（行锁：同行不兼容，不同行兼容）。</p><h3 id="额外讨论-2" tabindex="-1"><a class="header-anchor" href="#额外讨论-2"><span>额外讨论-2</span></a></h3><p>事务A获取了 <code>意向共享锁</code> ，事务B能否获取 <code>行级排他锁</code> 需要继续往下去判断，判断事务A的共享锁是表锁还是行锁，</p><p>如果是表锁，则事务B不能再加行级排他锁；</p><p>如果是行锁，则继续判断事务B要加行级排他锁的行是否被事务A或其他事务加了行级共享锁，如果加了，则事务B不能再加行级排他锁，如果这一行没加行级共享锁，则事务B可以加上行级排他锁（行锁：同行不兼容，不同行兼容）。</p>',34)]))}const c=e(o,[["render",n],["__file","index.html.vue"]]),i=JSON.parse('{"path":"/article/9awp9xq6/","title":"MySQL的意向锁","lang":"zh-CN","frontmatter":{"title":"MySQL的意向锁","createTime":"2025/03/05 23:17:15","permalink":"/article/9awp9xq6/","tags":["MySQL","锁"],"description":"深度解读MySQL意向锁的工作原理机制与应用场景。 MySQL的意向锁 意向锁的概念 意向锁是InnoDB自动添加的一种锁，不需要用户去干预。 是数据库中的一种表级锁，一个事务要给一个资源加锁时，必须要先获取到对应类型的意向锁之后，才可以给这个资源加上自己想要的共享锁或者排他锁（不论是行级还是表级的共享/排他锁，都是需要先获取到意向共享/排他锁）。 意...","head":[["meta",{"property":"og:url","content":"https://blog.gaohan.asia/article/9awp9xq6/"}],["meta",{"property":"og:site_name","content":"云泽汇码"}],["meta",{"property":"og:title","content":"MySQL的意向锁"}],["meta",{"property":"og:description","content":"深度解读MySQL意向锁的工作原理机制与应用场景。 MySQL的意向锁 意向锁的概念 意向锁是InnoDB自动添加的一种锁，不需要用户去干预。 是数据库中的一种表级锁，一个事务要给一个资源加锁时，必须要先获取到对应类型的意向锁之后，才可以给这个资源加上自己想要的共享锁或者排他锁（不论是行级还是表级的共享/排他锁，都是需要先获取到意向共享/排他锁）。 意..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-09T10:39:32.000Z"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"锁"}],["meta",{"property":"article:modified_time","content":"2025-03-09T10:39:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL的意向锁\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-09T10:39:32.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":4.86,"words":1459},"git":{"updatedTime":1741516772000,"contributors":[{"name":"yunze","username":"yunze","email":"56632502+YUNZE-GH@users.noreply.github.com","commits":4,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"}]},"autoDesc":true,"filePathRelative":"database/103.MySQL的意向锁.md","categoryList":[{"id":"11e0ee","sort":10005,"name":"database"}]}');export{c as comp,i as data};
