import{_ as s,e,f as i,o as t}from"./app-Cx_oisp2.js";const n={};function p(l,a){return t(),e("div",null,a[0]||(a[0]=[i(`<p>RabbitMQ有Connections连接、Channels信道、Exchanges交换机、和存储消息的Queues队列。</p><h2 id="基础理解" tabindex="-1"><a class="header-anchor" href="#基础理解"><span>基础理解</span></a></h2><ol><li><p>Connections连接 表示客户端与RabbitMQ之间的TCP连接；</p></li><li><p>Channels信道</p><p>客户端与RabbitMQ建立了连接之后，会分配一个AMQP信道Channel；</p><p>一个通信的通道；</p><p>一个Connection连接可以有多个Channel（便于客户端进行多线程连接）；</p></li><li><p>Exchanges交换机</p><p>主要功能是用于消息的转发，根据不同的规则转发到对应的队列当中；</p></li><li><p>Queues队列</p><p>用于消息实际存储转发的FIFO数据结构；</p></li></ol><h2 id="queue队列类型" tabindex="-1"><a class="header-anchor" href="#queue队列类型"><span>Queue队列类型</span></a></h2><p>Classic普通经典队列</p><ul><li><p>不需要交换机</p></li><li><p>当一个队列有多个消费者时，一个消息只会由一个消费者消费（竞争的消费者模式）</p></li><li><p>默认是轮询，即会将消息轮流发给多个消费者（测试的是每个消费者发送5次），对消费比较慢的消费者不公平</p></li><li><p>可采用公平分配，即能者多劳channel.basicQos(1);// 限定：发送一条信息给消费者A，消费者A未反馈处理结果之前，不会再次发送信息给消费者</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Aboolean</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">autoAck</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">取消自动反馈</span><span class="space"> </span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">channel</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">basicConsume</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">QUEUE_NAME</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">autoAck</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">consumer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">接收信息channel.basicAck(envelope.getDeliveryTag(),</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">false);</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">反馈消息处理完毕</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>Quorum仲裁队列</p><p>Stream流式队列</p>`,8)]))}const r=s(n,[["render",p],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/article/u3h32fkz/","title":"RabbitMQ的理解","lang":"zh-CN","frontmatter":{"title":"RabbitMQ的理解","createTime":"2025/03/07 13:43:58","permalink":"/article/u3h32fkz/","tags":["消息队列","RabbitMQ","理论"],"draft":true,"description":"RabbitMQ有Connections连接、Channels信道、Exchanges交换机、和存储消息的Queues队列。 基础理解 Connections连接 表示客户端与RabbitMQ之间的TCP连接； Channels信道 客户端与RabbitMQ建立了连接之后，会分配一个AMQP信道Channel； 一个通信的通道； 一个Connectio...","head":[["meta",{"property":"og:url","content":"https://blog.gaohan.asia/article/u3h32fkz/"}],["meta",{"property":"og:site_name","content":"云泽汇码"}],["meta",{"property":"og:title","content":"RabbitMQ的理解"}],["meta",{"property":"og:description","content":"RabbitMQ有Connections连接、Channels信道、Exchanges交换机、和存储消息的Queues队列。 基础理解 Connections连接 表示客户端与RabbitMQ之间的TCP连接； Channels信道 客户端与RabbitMQ建立了连接之后，会分配一个AMQP信道Channel； 一个通信的通道； 一个Connectio..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-02T02:30:37.000Z"}],["meta",{"property":"article:tag","content":"消息队列"}],["meta",{"property":"article:tag","content":"RabbitMQ"}],["meta",{"property":"article:tag","content":"理论"}],["meta",{"property":"article:modified_time","content":"2025-04-02T02:30:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RabbitMQ的理解\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-02T02:30:37.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":1.22,"words":366},"git":{"updatedTime":1743561037000,"contributors":[{"name":"yunze","username":"yunze","email":"56632502+YUNZE-GH@users.noreply.github.com","commits":6,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"}]},"autoDesc":true,"filePathRelative":"java/236.RabbitMQ的理解.md","categoryList":[{"id":"93f725","sort":10004,"name":"java"}]}');export{r as comp,c as data};
