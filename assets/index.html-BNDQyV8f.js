import{_ as i,e,f as n,o as t}from"./app-Cx_oisp2.js";const a="/assets/image-20250820214452673-Czogb5hi.png",p="/assets/Snipaste_2025-08-20_22-02-52-BQ2wZOTG.png",l="/assets/image-20250820220812147-DpJf_lg4.png",h="/assets/image-20250820213801462-CeOSg4TG.png",r={};function d(c,s){return t(),e("div",null,s[0]||(s[0]=[n('<p>通过在SQL语句的前面添加 <code>explain</code> 关键字，可以模拟 <code>优化器</code> 执行SQL语句（模拟，而不是执行），可以用来分析查询SQL语句的大概执行计划和可优化性能的点。</p><p>执行计划里有个关键数据，表明的了SQL的性能等级。</p><p>性能从高到低依次为 system---&gt;const---&gt;eq_ref---&gt;ref---&gt;range---&gt;index---&gt;all</p><p>需要确保SQL的性能达到range级别以上，最好达到ref</p><p>explain结果信息说明。</p><p><img src="'+a+`" alt="image-20250820214452673"></p><h2 id="id列" tabindex="-1"><a class="header-anchor" href="#id列"><span>id列</span></a></h2><p>id的编号就是MySQL执行SQL语句的顺序，id列值越高，其执行优先级越高，想同的id值，则是从上往下执行。id列值为null的最后执行。</p><h2 id="select-type列表" tabindex="-1"><a class="header-anchor" href="#select-type列表"><span>select_type列表</span></a></h2><p>用于表示查询sql是简单查询，还是复杂查询。</p><table><thead><tr><th>select_type列表值</th><th>说明</th></tr></thead><tbody><tr><td>simple</td><td>简单查询，不包含子查询和联表查询。</td></tr><tr><td>primary</td><td>复杂查询中的最外层select语句。</td></tr><tr><td>subquery</td><td>包含在select中，from前的子查询。</td></tr><tr><td>derived</td><td>包含在 <strong>from</strong> 子句中的子查询，MySQL会将其结果存放在一个临时表中，也称之为派生表。</td></tr><tr><td>union</td><td>使用union联表查询时的第二个select。</td></tr></tbody></table><h2 id="table列" tabindex="-1"><a class="header-anchor" href="#table列"><span>table列</span></a></h2><p>表示查询语句涉及到的表名。</p><p>如果table列的值是 <code>&lt;select_type列值 + id列值&gt;</code> 则表示是临时表。</p><h2 id="partitions列" tabindex="-1"><a class="header-anchor" href="#partitions列"><span>partitions列</span></a></h2><p>表示该查询是否涉及到分区表。（一般来说都直接分库分表了，不会使用分区表）</p><h2 id="type列" tabindex="-1"><a class="header-anchor" href="#type列"><span>type列</span></a></h2><p>性能高低按从左到右排序，system级别最高，all级别最低</p><p>system---&gt;const---&gt;eq_ref---&gt;ref---&gt;range---&gt;index---&gt;all</p><h3 id="system" tabindex="-1"><a class="header-anchor" href="#system"><span>system</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span class="space"> </span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">max</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">(id)</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">from</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">table_name;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span class="space"> </span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">min</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">(id)</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">from</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">table_name;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>像这种使用聚合函数来获取最大值最小值，因为使用的id是有索引的，而索引是有序递增的，所以可以直接获取，不需要查询。</p><h3 id="const" tabindex="-1"><a class="header-anchor" href="#const"><span>const</span></a></h3><p>是用于主键索引，或唯一索引进行等值查询时最多只会返回一条数据的情况下。因为结果数量是固定的（最多只有一条），只会读取一次，所以性能非常好。</p><p>而 <code>system</code> 则是特殊的const，当使用主键查询表，且只有一行数据时，就是 <code>system</code> 。性能极高。</p><h3 id="eq-ref" tabindex="-1"><a class="header-anchor" href="#eq-ref"><span>eq_ref</span></a></h3><p>主键等值查询。</p><p>在 <code>join</code> 连接查询中，<strong>对于来自前一张表的每一行，在当前表中只能找到唯一的一行与之匹配</strong>。通常是通过使用主键或唯一索引进行联表查询。</p><p>也就是在多表连接时，<strong>驱动表</strong> 的连接条件是 <strong>被驱动表</strong> 的 <strong>主键或唯一非空索引</strong> 。</p><p>例如：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">--</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">student表中的每一个class_id，在class表中都只能通过主键id找到唯一的一行记录。</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">FROM</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">student</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">JOIN</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">class</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">ON</span><span class="space"> </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">student</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">class_id</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span class="space"> </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">class</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">id</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">--</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">class.id</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">是班级表的主键</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="ref" tabindex="-1"><a class="header-anchor" href="#ref"><span>ref</span></a></h3><p>使用二级索引，也就是非主键索引进行等值查询时，因为结果不是唯一的，不确定有多少条数据符合条件，所以性能不如eq_ref，但也是一个比较高效的查询访问类型。</p><blockquote><p>使用 <strong>is null</strong> 也会触发该场景。</p><p><strong>冷知识：</strong> 在索引数据结构中，MySQL是将索引里所有为null的数据都集中在一个地方存储的。</p></blockquote><h3 id="range" tabindex="-1"><a class="header-anchor" href="#range"><span>range</span></a></h3><p>索引范围查询（&gt;、&lt;、&gt;=、&lt;=、in、between）。</p><p>会使用索引查询一个指定范围的区间数据，效率可以但是不如ref，因为查询得到的结果集可能非常多，所以建议结合分页进行使用。</p><h3 id="index" tabindex="-1"><a class="header-anchor" href="#index"><span>index</span></a></h3><p>全索引扫描，会扫描指定索引（二级索引）的所有数据，也就是不包含条件，但是要查询的结果字段在二级索引里都存在（ <strong>覆盖索引</strong> ）。</p><p>效率并不高，因为遍历扫描了整个索引树。</p><h3 id="all" tabindex="-1"><a class="header-anchor" href="#all"><span>all</span></a></h3><p>全表扫描，也就是扫描整个主键索引（聚集索引）的节点</p><h2 id="possible-key列" tabindex="-1"><a class="header-anchor" href="#possible-key列"><span>possible_key列</span></a></h2><p>表示SQL查询 <strong>可能</strong> 会使用到的索引。</p><h2 id="key列" tabindex="-1"><a class="header-anchor" href="#key列"><span>key列</span></a></h2><p>表示SQL在执行时会选择使用的索引。</p><h2 id="key-len列" tabindex="-1"><a class="header-anchor" href="#key-len列"><span>key_len列</span></a></h2><p><code>key_len</code> 列表示 <strong>MySQL 在本次查询中实际使用的索引部分的最大可能长度（单位：字节）</strong> 。</p><p>计算参考表</p><p>好的，这是为您格式化的 MySQL 常用数据类型在计算索引长度 (<code>key_len</code>) 时的开销对照表。</p><h3 id="mysql-数据类型索引长度-key-len-计算参考表" tabindex="-1"><a class="header-anchor" href="#mysql-数据类型索引长度-key-len-计算参考表"><span>MySQL 数据类型索引长度 (<code>key_len</code>) 计算参考表</span></a></h3><p>假设字符集为 <strong>utf8mb4</strong> (1字符=4字节)，该表展示了各类型在索引中的计算长度。</p><blockquote><p>字符集直接影响计算长度：</p><p>utf8、utf8mb3是3字节/字符</p><p>utf8mb4是4字节/字符</p></blockquote><p><img src="`+p+'" alt="Snipaste_2025-08-20_22-02-52"></p><p>例如：</p><p><img src="'+l+'" alt="image-20250820220812147"></p><p><img src="'+a+`" alt="image-20250820214452673"></p><p>这个key_len的值是63，parent_id是varchar(20)类型，且可以为null。</p><p>则计算方式是</p><p>utf8mb3：20 * 3 + 2 + 1 = 63</p><p>如果是utf8mb4：20 * 4 + 2 + 1 = 83</p><h2 id="rows列" tabindex="-1"><a class="header-anchor" href="#rows列"><span>rows列</span></a></h2><p>是MySQL预估的执行该语句会扫描的数据行数。</p><p>该值越小越好。</p><h2 id="filtered列" tabindex="-1"><a class="header-anchor" href="#filtered列"><span>filtered列</span></a></h2><p>是MySQL预估在进行查询条件where进行数据过滤后，剩余数据行的百分比。</p><p>该值越大越好。值越大，则表明where查询条件的效果非常好。</p><p>如果filtered为100，则表明所有扫描到的行都是需要的。</p><p>如果filtered为10，意味着存储引擎扫描了大量数据，其中90%被where中其他的非索引字段条件过滤了，说明索引设计的有问题。</p><h2 id="extra列" tabindex="-1"><a class="header-anchor" href="#extra列"><span>extra列</span></a></h2><p>常用值表明的意义如下</p><table><thead><tr><th>Extra值</th><th>说明</th></tr></thead><tbody><tr><td>using index</td><td>本次查询使用了索引，并且需要查询的结果字段完全被索引覆盖，不需要进行回表，也就是覆盖索引。</td></tr><tr><td>using index condition</td><td>本次查询使用了索引，但是需要查询的结果字段没有被索引完全覆盖，进行了回表。</td></tr><tr><td>using where</td><td>本次查询有过滤条件，但是过滤条件不存在索引，结果集也不存在索引。</td></tr><tr><td>using temporary</td><td>表示本次查询使用了临时</td></tr><tr><td>select tables optimized away</td><td>使用聚合函数获取存在于索引的字段值时，不需要去查表的场景。<br>如max(id)，min(id)，可以直接在索引上获取</td></tr><tr><td>using filesort</td><td>表示本次查询排序使用的是文件排序。没有走索引，性能较低，order by的字段应该加索引。</td></tr></tbody></table><h2 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引"><span>覆盖索引</span></a></h2><p>如果查询的结果字段在二级索引里都存在，那么MySQL会优先使用二级索引。</p><p>主键索引是聚集索引，叶子节点有完整的数据记录，也就代表着暂用的空间会更多，最终导致查询的扫描数据量会比二级索引（非聚集索引）更大。</p><p>例如</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">create</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">table</span><span class="space"> </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">student</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">(</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">id</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">primary</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">key</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">,</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">name</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">varchar</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">),</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">age</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">,</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">key</span><span class="space"> </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">\`</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">ix_name</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">\`</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">\`</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">name</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">\`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">)</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用以下命令查询时（没有条件）（如果有条件，则需要根据实际过滤条件来分析），</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">id,</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">name</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">from</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">student;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>因为结果集只有id和name两个字段，而这两个字段又都在 <code>ix_name</code> 二级索引（非聚集索引）中存在，所以无需回表，可以直接返回。</p><p>相比较去主键索引里查询要扫描的数据页会更多，所以这种结果集被二级索引覆盖的情况下，会优先选择二级索引。</p><p>这种情况就叫覆盖索引。</p><h2 id="sql常规优化方案" tabindex="-1"><a class="header-anchor" href="#sql常规优化方案"><span>SQL常规优化方案</span></a></h2><ol><li><p>不在索引字段上面做任何操作（包括计算、类型转换、函数操作），会导致索引失效而去进行全表扫描。</p></li><li><p>使用like进行模糊查询时，尽量不要左模糊，因为不会走索引，模糊查询的值，在索引里是不存在的（从左到右去比较）。</p></li><li><p>如果业务一定要使用左模糊查询，可以通过控制 select 查询结果字段，都是模糊条件字段所在索引数据结构上字段的方式，使其走索引（不是因为过滤条件去走的所以，而是因为查询结果字段被索引覆盖了，才去走的索引）。</p></li><li><p>如果是字符串类型字段，且该字段还有索引，则在进行条件查询时，一定要加单引号，否则其不会走索引，因为类型不同，不加单引号是数字，和字符串是不相等的。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">#</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">错误示范，不走索引</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">from</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">table_name</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">where</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">name</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1000</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">#</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">正确示范，走索引</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">from</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">table_name</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">where</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">name</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span class="space"> </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">1000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>少用 <strong>&#39;or&#39;</strong> 查询语句，不一定会走索引，可以优化为 <strong>&#39;union all&#39;</strong> 。</p></li><li><p><strong>&#39;in&#39;</strong> 查询语句，in里面的条件不太多可以，如果太多了可能不会走索引。</p></li><li><p>范围查询优化，当范围查询，如果范围太大了，MySQL就不会去走索引，会认为全表扫描更好，因为走二级索引，最好还需要去回表查询。这种情况可以考虑将一个大范围拆分为多个小范围条件去查询。</p></li></ol><h2 id="扩展" tabindex="-1"><a class="header-anchor" href="#扩展"><span>扩展</span></a></h2><p>explain可以结合 <code>show warnings;</code> 去查看MySQL对执行SQL的优化。（得出的结果SQL不一定能直接执行，只是告知MySQL会对SQL进行哪些优化。）</p><p><img src="`+h+'" alt="image-20250820213801462"></p>',87)]))}const o=i(r,[["render",d],["__file","index.html.vue"]]),g=JSON.parse('{"path":"/interview/ur0ukcpe/","title":"MySQL的Explain使用详细说明","lang":"zh-CN","frontmatter":{"title":"MySQL的Explain使用详细说明","createTime":"2025/08/19 23:59:50","tags":["数据库","MySQL","理论"],"permalink":"/interview/ur0ukcpe/","description":"通过在SQL语句的前面添加 explain 关键字，可以模拟 优化器 执行SQL语句（模拟，而不是执行），可以用来分析查询SQL语句的大概执行计划和可优化性能的点。 执行计划里有个关键数据，表明的了SQL的性能等级。 性能从高到低依次为 system--->const--->eq_ref--->ref--->range--->index--->all ...","head":[["meta",{"property":"og:url","content":"https://blog.gaohan.asia/interview/ur0ukcpe/"}],["meta",{"property":"og:site_name","content":"云泽汇码"}],["meta",{"property":"og:title","content":"MySQL的Explain使用详细说明"}],["meta",{"property":"og:description","content":"通过在SQL语句的前面添加 explain 关键字，可以模拟 优化器 执行SQL语句（模拟，而不是执行），可以用来分析查询SQL语句的大概执行计划和可优化性能的点。 执行计划里有个关键数据，表明的了SQL的性能等级。 性能从高到低依次为 system--->const--->eq_ref--->ref--->range--->index--->all ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-28T07:40:52.000Z"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"理论"}],["meta",{"property":"article:modified_time","content":"2025-08-28T07:40:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL的Explain使用详细说明\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-28T07:40:52.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":7.72,"words":2315},"git":{"updatedTime":1756366852000,"contributors":[{"name":"yunze","username":"yunze","email":"834363368@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"}]},"autoDesc":true,"filePathRelative":"notes/interview/1.MySQL/3.MySQL的Explain使用详细说明.md"}');export{o as comp,g as data};
