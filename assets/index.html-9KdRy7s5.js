import{_ as t,e as o,f as p,o as n}from"./app-Cx_oisp2.js";const i={};function c(r,e){return n(),o("div",null,e[0]||(e[0]=[p("<p>CAS的核心是原子性（CAS 是一种无锁化的原子操作）。</p><p>CAS是指令（CPU硬件层面的），所以不存在线程上下文切换</p><p>CAS的流程</p><p>CAS是怎么实现原子性的？</p><p>通过Unsafe类提供的本地方法实现的，但Unsafe很多方法是由c++去实现的，最底层是调用CPU硬件的原子性指令 <code>cmpxchg</code> 去实现的（compare and exchange）。</p><p>CAS的实现原理？</p><p>原理是CAS里包含3个关键参数：</p><ol><li><p>期望的旧值</p></li><li><p>将要更新的新值</p></li><li><p>要更新变量在对象内存中的偏移量地址</p></li></ol><p>通过比较指定内存地址的当前值是否与期望的旧值是否相同，如果相同，则交换为新值，否则自旋重新执行。</p><blockquote><p>原子操作正确场景：</p><ol><li><strong>读取</strong>内存位置 V 的当前值 A。</li><li><strong>比较</strong>当前值 A 是否等于预期值 E。</li><li><strong>如果相等，则交换</strong>为新值 U。</li></ol><p>非原子操作的灾难场景：</p><ol><li>线程1读取当前值 <code>A</code>。</li><li>在线程1比较之前，线程2也读取了当前值 <code>A</code>。</li><li>线程2将值从 <code>A</code> 成功更新为 <code>B</code>。</li><li>线程1此时执行比较，发现当前值 <strong>仍然是</strong> <code>A</code>（它读到的旧值），于是它也执行了更新操作。</li><li><strong>结果</strong>：线程2的更新被意外覆盖了！这完全违背了 CAS “只有在我之后没人修改过，我才能修改” 的设计初衷。</li></ol></blockquote><p>CAS存在ABA问题</p><p>库存原本是5，现在并发线程1要将其从5改为改为4（但是在准备修改为4时阻塞了），并发线程2要将其从5改为6，并发线程3将其从6改为5。等并发线程3执行完后，并发线程1介绍阻塞，将库存改为了4。</p><p>库存变化过程 5 --&gt; 6 --&gt; 5 --&gt; 4</p><p>对业务没有影响（CAS的目的达到了，进行比对时，库存值确实没有变化。如果只关心结果是没问题的）</p><blockquote><p>关心过程的案例，一个账户男女主同时在用，账户余额1万，男女主同时查询金额1万，女主取走1万消费，诈骗团伙转入1万，男主操作取款1万，ATM判断金额够，取款成功。</p><p>男主取款的1万是</p></blockquote><p>解决方案，可以添加版本号，可使用AtomicStasmpedReference原子类。</p>",16)]))}const l=t(i,[["render",c],["__file","index.html.vue"]]),s=JSON.parse('{"path":"/interview/cweeteev/","title":"CAS和Atomic原子操作类详解","lang":"zh-CN","frontmatter":{"title":"CAS和Atomic原子操作类详解","createTime":"2025/10/09 00:52:52","permalink":"/interview/cweeteev/","description":"CAS的核心是原子性（CAS 是一种无锁化的原子操作）。 CAS是指令（CPU硬件层面的），所以不存在线程上下文切换 CAS的流程 CAS是怎么实现原子性的？ 通过Unsafe类提供的本地方法实现的，但Unsafe很多方法是由c++去实现的，最底层是调用CPU硬件的原子性指令 cmpxchg 去实现的（compare and exchange）。 CA...","head":[["meta",{"property":"og:url","content":"https://blog.gaohan.asia/interview/cweeteev/"}],["meta",{"property":"og:site_name","content":"云泽汇码"}],["meta",{"property":"og:title","content":"CAS和Atomic原子操作类详解"}],["meta",{"property":"og:description","content":"CAS的核心是原子性（CAS 是一种无锁化的原子操作）。 CAS是指令（CPU硬件层面的），所以不存在线程上下文切换 CAS的流程 CAS是怎么实现原子性的？ 通过Unsafe类提供的本地方法实现的，但Unsafe很多方法是由c++去实现的，最底层是调用CPU硬件的原子性指令 cmpxchg 去实现的（compare and exchange）。 CA..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-26T12:40:27.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-26T12:40:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CAS和Atomic原子操作类详解\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-26T12:40:27.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":2.13,"words":638},"git":{"updatedTime":1761482427000,"contributors":[{"name":"yunze","username":"yunze","email":"834363368@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"}]},"autoDesc":true,"filePathRelative":"notes/interview/5.Concurrent/2.CAS和Atomic原子操作类详解.md"}');export{l as comp,s as data};
