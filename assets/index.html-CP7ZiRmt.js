import{_ as s,e,f as a,o as i}from"./app-Cx_oisp2.js";const l="/assets/image-20250929140033011-CP2d68zV.png",n="/assets/image-20250929140719076-tnMItHCY.png",d="/assets/image-20251004105217392-rk_xP58z.png",p="/assets/image-20250929143146955-D18IM-W9.png",r="/assets/image-20251004110904478-vq-KrHZw.png",o="/assets/image-20250930093629080-Ci8aPprM.png",h="/assets/image-20250930095536328-CZ5A5N-S.png",c="/assets/image-20250930100502644-BrumJjPd.png",g={};function k(y,t){return i(),e("div",null,t[0]||(t[0]=[a(`<h2 id="jmap" tabindex="-1"><a class="header-anchor" href="#jmap"><span>Jmap</span></a></h2><h3 id="_1-查看内存里对象实例信息" tabindex="-1"><a class="header-anchor" href="#_1-查看内存里对象实例信息"><span>1. 查看内存里对象实例信息</span></a></h3><p>可以用来查看内存信息，实例个数以及占用内存大小。</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">先使用jps命令查询出应用的进程ID</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">然后使用jmap查看内存信息</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">jmap</span><span class="space"> </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">-histo</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">PI</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">D</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">./memory-log.txt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+l+'" alt="image-20250929140033011"></p><p>展示数据说明</p><ol><li><p>num（序号）</p></li><li><p>instances（实例数量）</p></li><li><p>bytes（占用空间大小）</p></li><li><p>class name（类名称）</p><p>[C 是一个 char 数组</p><p>[S 是一个 short 数组</p><p>[[I 是一个 int 数组</p><p>[[B 是一个 byte 数组</p><p>[[I 是一个 int 二位数组</p></li></ol><h3 id="_2-查看堆内存信息" tabindex="-1"><a class="header-anchor" href="#_2-查看堆内存信息"><span>2. 查看堆内存信息</span></a></h3><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">jmap</span><span class="space"> </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">-heap</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">PI</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">D</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="'+n+'" alt="image-20250929140719076"></p><p>参数解读</p><h4 id="堆内存配置信息-heap-configuration" tabindex="-1"><a class="header-anchor" href="#堆内存配置信息-heap-configuration"><span>堆内存配置信息 Heap Configuration</span></a></h4><table><thead><tr><th>参数</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td><code>MaxHeapSize</code></td><td>2048.0MB</td><td>堆最大 2GB</td></tr><tr><td><code>NewSize</code> / <code>MaxNewSize</code></td><td>768.0MB</td><td>年轻代固定大小（-Xmn768m）</td></tr><tr><td><code>OldSize</code></td><td>1280.0MB</td><td>老年代大小</td></tr><tr><td><code>NewRatio</code></td><td>2</td><td>老年代 : 年轻代 = 2:1</td></tr><tr><td><code>SurvivorRatio</code></td><td>8</td><td>Eden : From : To = 8:1:1</td></tr><tr><td><code>MaxMetaspaceSize</code></td><td>256.0MB</td><td>元空间最大 256MB（已设置限制）</td></tr></tbody></table><h4 id="堆内存使用情况-heap-usage" tabindex="-1"><a class="header-anchor" href="#堆内存使用情况-heap-usage"><span>堆内存使用情况 Heap Usage</span></a></h4><h5 id="年轻代-首尔区" tabindex="-1"><a class="header-anchor" href="#年轻代-首尔区"><span>年轻代+首尔区</span></a></h5><p>New Generation (Eden + 1 Survivor Space)</p><ul><li><strong>总容量</strong> 为 691.25 MB</li><li><strong>已使用</strong> 为 404.09 MB（<strong>58.5%</strong>）</li><li><strong>Eden 区使用率</strong> 为 54.6%</li><li><strong>From Survivor 使用率</strong> 为 89.2%</li><li><strong>To Survivor</strong> 为 空</li></ul><h5 id="老年代" tabindex="-1"><a class="header-anchor" href="#老年代"><span>老年代</span></a></h5><p>CMS垃圾收集器 concurrent mark-sweep generation</p><ul><li><strong>总容量</strong>：1280.0 MB</li><li><strong>已使用</strong>：236.79 MB（<strong>18.5%</strong>）</li></ul><h3 id="_3-堆内存dump" tabindex="-1"><a class="header-anchor" href="#_3-堆内存dump"><span>3. 堆内存dump</span></a></h3><p>dump文件是什么？</p><p>简单来说，Dump 文件是 JVM 在特定时刻的“内存快照”或“事故现场黑匣子记录”。</p><p>它完整地保存了当时 JVM 堆内存中所有对象的信息。</p><h4 id="手动dump命令" tabindex="-1"><a class="header-anchor" href="#手动dump命令"><span>手动dump命令</span></a></h4><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">jmap</span><span class="space"> </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">-dump:format=b,file=jvm-oom.dump</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">PI</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">D</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="出现oom自动dump" tabindex="-1"><a class="header-anchor" href="#出现oom自动dump"><span>出现oom自动dump</span></a></h4><p>设置堆内存溢出时自动导出dump文件（内存很大的时候，可能会导不出来），保存系统出现异常时的现场</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">‐XX:+HeapDumpOnOutOfMemoryError</span><span class="space"> </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">‐XX:HeapDumpPath=./jvm-oom.dump</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个dump文件加载到 visualVM 工具里可以看内存里类的实例数和大小。</p><p><img src="'+d+'" alt="image-20251004105217392"></p><p><img src="'+p+'" alt="image-20250929143146955"></p><p>一般按照count和size排序后，找到的第一个自己开发应用的对象，也就找到了出现内存泄漏的问题所在。</p><h2 id="jstack" tabindex="-1"><a class="header-anchor" href="#jstack"><span>Jstack</span></a></h2><p>可以用 jstack 加进程id查找死锁</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">jstack</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">PI</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">D</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="'+r+'" alt="image-20251004110904478"></p><table><thead><tr><th style="text-align:left;">状态</th><th style="text-align:left;">含义</th><th style="text-align:left;">常见原因与排查方向</th></tr></thead><tbody><tr><td style="text-align:left;"><strong><code>RUNNABLE</code></strong></td><td style="text-align:left;">可运行或正在运行</td><td style="text-align:left;">CPU密集型任务、IO等待（可能）、自旋</td></tr><tr><td style="text-align:left;"><strong><code>TIMED_WAITING</code></strong></td><td style="text-align:left;">有限时间等待</td><td style="text-align:left;">Sleep调用、带超时的锁等待、IO操作（带超时）</td></tr><tr><td style="text-align:left;"><strong><code>WAITING</code></strong></td><td style="text-align:left;">无限时间等待</td><td style="text-align:left;">无超时的 <code>wait()</code> , <code>join()</code> , <code>LockSupport.park()</code> ，可能表示资源未就绪或协调问题</td></tr><tr><td style="text-align:left;"><strong><code>BLOCKED</code></strong></td><td style="text-align:left;">等待进入同步区</td><td style="text-align:left;">激烈的锁竞争，是 <strong>性能瓶颈和潜在死锁</strong> 的典型标志</td></tr></tbody></table><h3 id="找出占用cpu最高的线程堆栈信息" tabindex="-1"><a class="header-anchor" href="#找出占用cpu最高的线程堆栈信息"><span>找出占用cpu最高的线程堆栈信息</span></a></h3><ol><li><p>使用命令 <code>top -p &lt;pid&gt;</code> ，显示你的java进程的内存情况，pid是应用的java进程号</p></li><li><p>按大写的H，获取每个线程的内存情况</p></li><li><p>找到内存和cpu占用最高的线程PID</p></li><li><p>将这个PID转为十六进制得到 0xa32f，此为线程id的十六进制表示</p></li><li><p>执行 <code>jstack 19663 | grep -A 10 a32f</code>，得到线程堆栈信息中 a32f 这个线程所在行的后面10行，从堆栈中可以发现导致cpu飙高的调用方法</p></li><li><p>查看对应的堆栈信息找出可能存在问题的代码</p></li></ol><h2 id="jinfo" tabindex="-1"><a class="header-anchor" href="#jinfo"><span>Jinfo</span></a></h2><p>可以查看正在运行的Java应用程序的扩展参数</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">jinfo</span><span class="space"> </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">-flags</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">PI</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">D</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="'+o+'" alt="image-20250930093629080"></p><p>查看java系统参数</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">jinfo</span><span class="space"> </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">-sysprops</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">PI</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">D</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="'+h+`" alt="image-20250930095536328"></p><h2 id="jstat" tabindex="-1"><a class="header-anchor" href="#jstat"><span>Jstat</span></a></h2><p>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。</p><p>命令的格式如下：</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">jstat</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">[-命令选项]</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">vmid</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">间隔时间</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">毫秒</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)]</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">查询次数</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>例</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">每间隔5000毫秒，查询一次信息，共查询10次</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">jstat</span><span class="space"> </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">-gc</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">3774520</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">5000</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+c+'" alt="image-20250930100502644"></p><h3 id="jvm-内存与gc监控指标" tabindex="-1"><a class="header-anchor" href="#jvm-内存与gc监控指标"><span>JVM 内存与GC监控指标</span></a></h3><table><thead><tr><th style="text-align:left;">缩写</th><th style="text-align:left;">全称</th><th style="text-align:left;">含义</th><th style="text-align:left;">单位</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>S0C</strong></td><td style="text-align:left;">Survivor 0 Capacity</td><td style="text-align:left;">第一个幸存区（From Survivor）的总容量</td><td style="text-align:left;">KB</td></tr><tr><td style="text-align:left;"><strong>S1C</strong></td><td style="text-align:left;">Survivor 1 Capacity</td><td style="text-align:left;">第二个幸存区（To Survivor）的总容量</td><td style="text-align:left;">KB</td></tr><tr><td style="text-align:left;"><strong>S0U</strong></td><td style="text-align:left;">Survivor 0 Used</td><td style="text-align:left;">第一个幸存区（From Survivor）的已使用量</td><td style="text-align:left;">KB</td></tr><tr><td style="text-align:left;"><strong>S1U</strong></td><td style="text-align:left;">Survivor 1 Used</td><td style="text-align:left;">第二个幸存区（To Survivor）的已使用量</td><td style="text-align:left;">KB</td></tr><tr><td style="text-align:left;"><strong>EC</strong></td><td style="text-align:left;">Eden Capacity</td><td style="text-align:left;">伊甸园区（Eden）的总容量</td><td style="text-align:left;">KB</td></tr><tr><td style="text-align:left;"><strong>EU</strong></td><td style="text-align:left;">Eden Used</td><td style="text-align:left;">伊甸园区（Eden）的已使用量</td><td style="text-align:left;">KB</td></tr><tr><td style="text-align:left;"><strong>OC</strong></td><td style="text-align:left;">Old Capacity</td><td style="text-align:left;">老年代（Old Generation）的总容量</td><td style="text-align:left;">KB</td></tr><tr><td style="text-align:left;"><strong>OU</strong></td><td style="text-align:left;">Old Used</td><td style="text-align:left;">老年代（Old Generation）的已使用量</td><td style="text-align:left;">KB</td></tr><tr><td style="text-align:left;"><strong>MC</strong></td><td style="text-align:left;">Metaspace Capacity</td><td style="text-align:left;">方法区（元空间）的总容量</td><td style="text-align:left;">KB</td></tr><tr><td style="text-align:left;"><strong>MU</strong></td><td style="text-align:left;">Metaspace Used</td><td style="text-align:left;">方法区（元空间）的已使用量</td><td style="text-align:left;">KB</td></tr><tr><td style="text-align:left;"><strong>CCSC</strong></td><td style="text-align:left;">Compressed Class Space Capacity</td><td style="text-align:left;">压缩类空间的总容量</td><td style="text-align:left;">KB</td></tr><tr><td style="text-align:left;"><strong>CCSU</strong></td><td style="text-align:left;">Compressed Class Space Used</td><td style="text-align:left;">压缩类空间的已使用量</td><td style="text-align:left;">KB</td></tr><tr><td style="text-align:left;"><strong>YGC</strong></td><td style="text-align:left;">Young Generation Collections</td><td style="text-align:left;">年轻代垃圾回收发生的次数</td><td style="text-align:left;">次</td></tr><tr><td style="text-align:left;"><strong>YGCT</strong></td><td style="text-align:left;">Young Generation Collection Time</td><td style="text-align:left;">年轻代垃圾回收消耗的总时间</td><td style="text-align:left;">秒 (s)</td></tr><tr><td style="text-align:left;"><strong>FGC</strong></td><td style="text-align:left;">Full GC Collections</td><td style="text-align:left;"><strong>Full GC</strong> 发生的次数</td><td style="text-align:left;">次</td></tr><tr><td style="text-align:left;"><strong>FGCT</strong></td><td style="text-align:left;">Full GC Collection Time</td><td style="text-align:left;"><strong>Full GC</strong> 消耗的总时间</td><td style="text-align:left;">秒 (s)</td></tr><tr><td style="text-align:left;"><strong>GCT</strong></td><td style="text-align:left;">Total Garbage Collection Time</td><td style="text-align:left;">垃圾回收消耗的总时间（YGCT + FGCT）</td><td style="text-align:left;">秒 (s)</td></tr></tbody></table><ol><li><p><strong>FGC 的真正含义</strong>： <code>FGC</code> / <code>FGCT</code> 指标通常指的是 <strong>Full GC</strong> 的次数和时间，而不仅仅是“老年代GC”。</p><ul><li><strong>Full GC</strong> 会回收整个堆，包括<strong>年轻代</strong>、<strong>老年代</strong>，通常还包括<strong>方法区（元空间）</strong>。</li><li>而专门针对老年代的回收（例如 CMS 的并发回收）通常不统计在 <code>FGC</code> 内。</li><li>因此，<strong><code>FGC</code> 是需要极力避免的，因为它会导致长时间的 STW（Stop-The-World）停顿。</strong></li></ul></li><li><p><strong>指标解读技巧</strong>：</p><ul><li><strong>内存健康度</strong>：关注各区域的 <code>Used</code> 与 <code>Capacity</code> 的比值。例如，如果 <code>OU</code> 持续很高，接近 <code>OC</code>，可能预示老年代即将被填满，会触发 Full GC。</li><li><strong>GC 效率</strong>： <ul><li><strong>YGC 频率</strong>：<code>EU</code> 增长越快，<code>YGC</code> 频率越高。</li><li><strong>平均 YGC 耗时</strong>：<code>YGCT / YGC</code>。如果这个值突然变长，可能意味着有问题。</li><li><strong>Full GC 情况</strong>：<strong><code>FGC</code> 次数不应持续增长</strong>。如果 <code>FGC</code> 很频繁且 <code>FGCT</code> 很长，是严重的性能警报。</li></ul></li></ul></li></ol><h2 id="调优实战" tabindex="-1"><a class="header-anchor" href="#调优实战"><span>调优实战</span></a></h2><h3 id="关注如下几个指标" tabindex="-1"><a class="header-anchor" href="#关注如下几个指标"><span>关注如下几个指标</span></a></h3><h4 id="_1-年轻代对象增长的速率" tabindex="-1"><a class="header-anchor" href="#_1-年轻代对象增长的速率"><span>1. 年轻代对象增长的速率</span></a></h4><p>可以通过执行命令 <code>jstat -gc pid 1000 10</code> (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对象。</p><h4 id="_2-young-gc触发频率和耗时" tabindex="-1"><a class="header-anchor" href="#_2-young-gc触发频率和耗时"><span>2. Young GC触发频率和耗时</span></a></h4><p>关注Young GC大概多久触发一次，Young GC的平均耗时可以通过 <code>YGCT / YGC</code> 公式算出，根据结果我们大概就能知道系统大概多久会因为Young GC的执行而卡顿多久。</p><h4 id="_3-每次young-gc后有多少对象存活进入老年代" tabindex="-1"><a class="header-anchor" href="#_3-每次young-gc后有多少对象存活进入老年代"><span>3. 每次Young GC后有多少对象存活进入老年代</span></a></h4><p>可以关注每次young gc后，老年代区域内存使用情况增长率。</p><h4 id="_4-full-gc的触发频率和耗时" tabindex="-1"><a class="header-anchor" href="#_4-full-gc的触发频率和耗时"><span>4. Full GC的触发频率和耗时</span></a></h4><p>知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT/FGC 计算得出。</p><h3 id="优化思路" tabindex="-1"><a class="header-anchor" href="#优化思路"><span>优化思路</span></a></h3><p>尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年 代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。</p>',69)]))}const m=s(g,[["render",k],["__file","index.html.vue"]]),f=JSON.parse('{"path":"/interview/5gmpkvz8/","title":"JVM调优工具与实战","lang":"zh-CN","frontmatter":{"title":"JVM调优工具与实战","createTime":"2025/10/09 00:52:52","permalink":"/interview/5gmpkvz8/","description":"Jmap 1. 查看内存里对象实例信息 可以用来查看内存信息，实例个数以及占用内存大小。 image-20250929140033011 展示数据说明 num（序号） instances（实例数量） bytes（占用空间大小） class name（类名称） [C 是一个 char 数组 [S 是一个 short 数组 [[I 是一个 int 数组 [...","head":[["meta",{"property":"og:url","content":"https://blog.gaohan.asia/interview/5gmpkvz8/"}],["meta",{"property":"og:site_name","content":"云泽汇码"}],["meta",{"property":"og:title","content":"JVM调优工具与实战"}],["meta",{"property":"og:description","content":"Jmap 1. 查看内存里对象实例信息 可以用来查看内存信息，实例个数以及占用内存大小。 image-20250929140033011 展示数据说明 num（序号） instances（实例数量） bytes（占用空间大小） class name（类名称） [C 是一个 char 数组 [S 是一个 short 数组 [[I 是一个 int 数组 [..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-26T12:40:27.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-26T12:40:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM调优工具与实战\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-26T12:40:27.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":5.94,"words":1782},"git":{"updatedTime":1761482427000,"contributors":[{"name":"yunze","username":"yunze","email":"834363368@qq.com","commits":5,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"}]},"autoDesc":true,"filePathRelative":"notes/interview/4.JVM/6.JVM调优工具与实战.md"}');export{m as comp,f as data};
