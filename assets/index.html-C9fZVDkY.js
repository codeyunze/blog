import{_ as n,e as l,f as a,g as t,h as i,i as p,j as h,r,o as d}from"./app-Cx_oisp2.js";const k="/assets/%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98-DVC18qWd.png",o="/assets/%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98-Dyy0Q5zS.png",c={};function y(g,s){const e=r("RouteLink");return d(),l("div",null,[s[3]||(s[3]=a('<h2 id="缓存、数据双写一致性问题" tabindex="-1"><a class="header-anchor" href="#缓存、数据双写一致性问题"><span>缓存、数据双写一致性问题</span></a></h2><h3 id="双写不一致" tabindex="-1"><a class="header-anchor" href="#双写不一致"><span>双写不一致</span></a></h3><p><img src="'+k+'" alt="缓存-数据双写不一致性问题"></p><h3 id="读写不一致" tabindex="-1"><a class="header-anchor" href="#读写不一致"><span>读写不一致</span></a></h3><p><img src="'+o+'" alt="缓存-数据读写不一致性问题"></p><h3 id="优化方案" tabindex="-1"><a class="header-anchor" href="#优化方案"><span>优化方案</span></a></h3>',6)),t("p",null,[s[1]||(s[1]=i("《 ")),p(e,{to:"/database/125.Redis%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.html"},{default:h(()=>s[0]||(s[0]=[i("Redis缓存与数据库数据一致性问题")])),_:1}),s[2]||(s[2]=i(" 》"))]),s[4]||(s[4]=a(`<p>如果不能容忍缓存数据不一致，可以通过加 <strong>分布式读写锁</strong> 保证并发读写或写写的时候按顺序排好队，读读的 时候相当于无锁。（比较推荐）</p><h2 id="redis过期键清除策略" tabindex="-1"><a class="header-anchor" href="#redis过期键清除策略"><span>Redis过期键清除策略</span></a></h2><h3 id="被动删除" tabindex="-1"><a class="header-anchor" href="#被动删除"><span>被动删除</span></a></h3><p>当读/写一个已经过期的key时，会触发惰性删除策略，会直接删除掉这个过期key。</p><h3 id="主动删除" tabindex="-1"><a class="header-anchor" href="#主动删除"><span>主动删除</span></a></h3><p>惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key。</p><h3 id="触发主动清理策略" tabindex="-1"><a class="header-anchor" href="#触发主动清理策略"><span>触发主动清理策略</span></a></h3><p>当内存超过maxmemory限定时，会触发主动清理策略。</p><p>内存主动淘汰策略如下</p><h4 id="针对设置了过期时间的key做处理" tabindex="-1"><a class="header-anchor" href="#针对设置了过期时间的key做处理"><span>针对设置了过期时间的key做处理：</span></a></h4><ul><li><p>volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删 除，越早过期的越先被删除。</p></li><li><p>volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</p></li><li><p>volatile-lru：会使用 LRU 算法筛选设置了过期时间的键值对删除。</p></li><li><p>volatile-lfu：会使用 LFU 算法筛选设置了过期时间的键值对删除。</p></li></ul><h4 id="针对所有的key做处理" tabindex="-1"><a class="header-anchor" href="#针对所有的key做处理"><span>针对所有的key做处理：</span></a></h4><ul><li><p>allkeys-random：从所有键值对中随机选择并删除数据。</p></li><li><p>allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除。</p></li><li><p>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除。</p></li></ul><h4 id="不处理" tabindex="-1"><a class="header-anchor" href="#不处理"><span>不处理：</span></a></h4><ul><li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息&quot;(error) OOM comm</li></ul><blockquote><p><strong>缓存淘汰算法</strong></p><p><strong>LRU 算法</strong>（Least Recently Used，最近最少使用）：</p><p>淘汰很久没被访问过的数据，以最近一次访问时间作为参考。</p><p><strong>LFU 算法</strong>（Least Frequently Used，最不经常使用）：</p><p>淘汰最近一段时间被访问次数最少的数据，以次数作为参考。</p></blockquote><blockquote><p>当Redis运行在主从模式时，只有主结点才会执行过期删除策略，然后把删除操作”del key”同步到从结点删除数据。</p></blockquote><h3 id="配置方式" tabindex="-1"><a class="header-anchor" href="#配置方式"><span>配置方式</span></a></h3><div class="language-properties line-numbers-mode" data-ext="properties" data-title="properties"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">设置最大内存，例如</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">4GB</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">maxmemory</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">4gb</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">选择驱逐策略，例如</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">volatile-lru</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">maxmemory-policy</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">volatile-lru</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">（可选）设置LRU/LFU算法的采样精度</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">maxmemory-samples</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">10</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="bigkey的危害" tabindex="-1"><a class="header-anchor" href="#bigkey的危害"><span>bigkey的危害</span></a></h2><blockquote><ol><li>**字符串类型：**它的big体现在单个value值很大，一般认为超过10KB就是bigkey。</li><li>**非字符串类型：**哈希、列表、集合、有序集合，它们的big体现在元素个数太多，一般不要超过5000。</li></ol></blockquote><h3 id="危害" tabindex="-1"><a class="header-anchor" href="#危害"><span>危害</span></a></h3><p>导致redis阻塞：redis的核心读写是单线程操作的，bigkey会阻塞后续排队的请求。</p><p>导致网络的阻塞：如果一个bigkey是1MB，则每秒1000个客户端请求，就每秒产生了1000MB的流量，但是千兆网卡(按照字节算是128MB/s)根本处理不过来。</p><p>过期删除时阻塞redis：当bigkey到期后删除时，会阻塞redis其他操作。</p><h3 id="优化" tabindex="-1"><a class="header-anchor" href="#优化"><span>优化</span></a></h3><p>list类型可拆分为list1、list2...listN。</p><p>控制一个hash不要存过多field，可拆分为多个hash缓存key。</p><p>hash获取元素时，如果是bigkey，可以考虑使用 <code>hmget</code> ，只取需要的元素字段，而不是使用 <code>hgetall</code> 。</p><p>控制key的生命周期。</p><h2 id="布隆过滤器" tabindex="-1"><a class="header-anchor" href="#布隆过滤器"><span>布隆过滤器</span></a></h2><blockquote><p><strong>布隆过滤器里没有的，则数据里一定没有，布隆过滤器里有的，数据库里不一定有。</strong></p></blockquote><p>对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不 存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。</p><p>在初始化布隆过滤器时，将所有数据存入布隆过滤器里。</p><p>布隆过滤器由 <strong>bit数组</strong> 组成，代码维护较为复杂（新增数据时，需要同时在布隆过滤器上标记，且布隆过滤器不支持删除数据，只能重新初始化数据）， 但是缓存空间占用很少。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">初始化布隆过滤器</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">RBloomFilter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">bloomFilter</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">redisson</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getBloomFilter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">nameList</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">初始化布隆过滤器：预计元素为100000000L,误差率为3%</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">bloomFilter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">tryInit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100000000L</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0.03</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">往布隆过滤器里标记key</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">bloomFilter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">put</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">user:10001</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span><span class="space"> </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">从布隆过滤器里判断下key是否存在</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Boolean</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">exist</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span class="space"> </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">bloomFilter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">contains</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,36))])}const m=n(c,[["render",y],["__file","index.html.vue"]]),D=JSON.parse('{"path":"/interview/oo5jj2eh/","title":"Redis缓存设计","lang":"zh-CN","frontmatter":{"title":"Redis缓存设计","createTime":"2025/08/31 20:31:30","permalink":"/interview/oo5jj2eh/","description":"缓存、数据双写一致性问题 双写不一致 缓存-数据双写不一致性问题 读写不一致 缓存-数据读写不一致性问题 优化方案 《 》 如果不能容忍缓存数据不一致，可以通过加 分布式读写锁 保证并发读写或写写的时候按顺序排好队，读读的 时候相当于无锁。（比较推荐） Redis过期键清除策略 被动删除 当读/写一个已经过期的key时，会触发惰性删除策略，会直接删除掉...","head":[["meta",{"property":"og:url","content":"https://blog.gaohan.asia/interview/oo5jj2eh/"}],["meta",{"property":"og:site_name","content":"云泽汇码"}],["meta",{"property":"og:title","content":"Redis缓存设计"}],["meta",{"property":"og:description","content":"缓存、数据双写一致性问题 双写不一致 缓存-数据双写不一致性问题 读写不一致 缓存-数据读写不一致性问题 优化方案 《 》 如果不能容忍缓存数据不一致，可以通过加 分布式读写锁 保证并发读写或写写的时候按顺序排好队，读读的 时候相当于无锁。（比较推荐） Redis过期键清除策略 被动删除 当读/写一个已经过期的key时，会触发惰性删除策略，会直接删除掉..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-06T01:26:28.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-06T01:26:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis缓存设计\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-06T01:26:28.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":4.06,"words":1219},"git":{"updatedTime":1757121988000,"contributors":[{"name":"yunze","username":"yunze","email":"834363368@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"}]},"autoDesc":true,"filePathRelative":"notes/interview/2.Redis/6.Redis缓存设计.md"}');export{m as comp,D as data};
