import{_ as t,e as a,f as r,o as n}from"./app-Cx_oisp2.js";const o={};function i(p,e){return n(),a("div",null,e[0]||(e[0]=[r('<p>简单介绍事务里常见的4种隔离级别，未提交读、读已提交、可重复读和串行读</p><h2 id="未提交读-read-uncommitted" tabindex="-1"><a class="header-anchor" href="#未提交读-read-uncommitted"><span>未提交读(Read Uncommitted)</span></a></h2><p>允许脏读，也就是可能读取到其他事务中更新了，但是还没有提交的数据。</p><h2 id="读已提交-read-committed" tabindex="-1"><a class="header-anchor" href="#读已提交-read-committed"><span>读已提交(Read Committed)</span></a></h2><p>只能读取到已经提交的数据。</p><h2 id="可重复读-repeated-read" tabindex="-1"><a class="header-anchor" href="#可重复读-repeated-read"><span>可重复读(Repeated Read)</span></a></h2><p>在同一个事务内，同一查询语句经过多次执行，得到的结果都会和事务第一次指定的查询结果保持一致，即使在这期间其他的事务对数据进行了修改（除非在本事务里也有进行一次update操作，</p><p>在SQL标准中，这个隔离级别解决了不可重复读问题，但是还会存在幻读情况，但是InnoDB为了解决幻读引入的一种锁机制，叫间隙锁。</p><h2 id="串行读-serializable" tabindex="-1"><a class="header-anchor" href="#串行读-serializable"><span>串行读(Serializable)</span></a></h2><p>完全串行化的读，每次读数据都需要获得表级共享锁，读写相互都会阻塞。是一种性能很低的隔离级别。</p>',10)]))}const c=t(o,[["render",i],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/article/6x61v814/","title":"事务的隔离级别","lang":"zh-CN","frontmatter":{"title":"事务的隔离级别","createTime":"2025/03/05 13:54:28","permalink":"/article/6x61v814/","tags":["数据库","MySQL","事务"],"description":"简单介绍事务里常见的4种隔离级别，未提交读、读已提交、可重复读和串行读 未提交读(Read Uncommitted) 允许脏读，也就是可能读取到其他事务中更新了，但是还没有提交的数据。 读已提交(Read Committed) 只能读取到已经提交的数据。 可重复读(Repeated Read) 在同一个事务内，同一查询语句经过多次执行，得到的结果都会和...","head":[["meta",{"property":"og:url","content":"https://blog.gaohan.asia/article/6x61v814/"}],["meta",{"property":"og:site_name","content":"云泽汇码"}],["meta",{"property":"og:title","content":"事务的隔离级别"}],["meta",{"property":"og:description","content":"简单介绍事务里常见的4种隔离级别，未提交读、读已提交、可重复读和串行读 未提交读(Read Uncommitted) 允许脏读，也就是可能读取到其他事务中更新了，但是还没有提交的数据。 读已提交(Read Committed) 只能读取到已经提交的数据。 可重复读(Repeated Read) 在同一个事务内，同一查询语句经过多次执行，得到的结果都会和..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-19T14:40:01.000Z"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"事务"}],["meta",{"property":"article:modified_time","content":"2025-08-19T14:40:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"事务的隔离级别\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-19T14:40:01.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":0.97,"words":291},"git":{"updatedTime":1755614401000,"contributors":[{"name":"yunze","username":"yunze","email":"56632502+YUNZE-GH@users.noreply.github.com","commits":1,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"},{"name":"yunze","username":"yunze","email":"834363368@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"}]},"autoDesc":true,"filePathRelative":"database/105.事务的隔离级别.md","categoryList":[{"id":"11e0ee","sort":10005,"name":"database"}]}');export{c as comp,m as data};
