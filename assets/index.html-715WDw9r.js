import{_ as p,e as d,g as a,f as l,h as t,i,j as n,r,o as h}from"./app-Cx_oisp2.js";const c="/assets/image-20250822215248772-DZofREJ5.png",o={};function k(g,s){const e=r("RouteLink");return h(),d("div",null,[s[9]||(s[9]=a("p",null,"一组数据操作，要么全部成功，要么全部失败，目的是实现数据的一致性。",-1)),s[10]||(s[10]=a("p",null,"​ ----事务",-1)),s[11]||(s[11]=a("p",null,"事务的隔离级别从高到低排序如下（高并发性能也是）",-1)),s[12]||(s[12]=a("p",null,"未提交读--->读已提交--->可重复读--->串行读",-1)),s[13]||(s[13]=a("h2",{id:"事务的acid底层原理",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#事务的acid底层原理"},[a("span",null,"事务的ACID底层原理")])],-1)),s[14]||(s[14]=a("p",null,"事务的四大特性：原子性、一致性、隔离性、持久性",-1)),a("p",null,[s[1]||(s[1]=t("详细说明可参考《 ")),i(e,{to:"/database/106.%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7(4%E4%B8%AA%E7%89%B9%E5%BE%81).html"},{default:n(()=>s[0]||(s[0]=[t("事务的ACID特性(4个特征)")])),_:1}),s[2]||(s[2]=t(" 》"))]),s[15]||(s[15]=l('<h2 id="并发场景下事务处理存在的问题" tabindex="-1"><a class="header-anchor" href="#并发场景下事务处理存在的问题"><span>并发场景下事务处理存在的问题</span></a></h2><blockquote><p>想学习了解事务的隔离级别，就需要先知道并发场景下事务会出现哪些问题，什么样的隔离级别解决了什么样的问题。</p></blockquote><h3 id="脏读" tabindex="-1"><a class="header-anchor" href="#脏读"><span>脏读</span></a></h3><p>事务A更新了id为1的数据，但是还没有提交，此时事务B读取到了id为1的数据（被事务A更新后的数据），然后做了一系列的业务操作，但是最终事务A却回滚了对id为1数据的更新。</p><p><strong>总结：事务B读取到事务A已经更新但未提交的数据，并做了业务操作后，事务A回滚了更新数据，导致了数据一致性问题。</strong></p><h3 id="脏写" tabindex="-1"><a class="header-anchor" href="#脏写"><span>脏写</span></a></h3><p>事务A查询id为1的数据，余额为10。然后事务B中途插入进来给id为1的数据余额加10，并提交了事务，此时余额变成了20。然后事务A也开始了自己的业务逻辑，代码里将刚才查询的余额10（事务A获取余额时，事务B还没提交事务），扣减5，余额5，最后提交事务。</p><p>这样就导致事务B操作的余额数据，被事务A给覆盖掉了，这就是脏写。</p><p><strong>总结：事务A最后更新的更新覆盖了事务B所操作的更新。</strong></p><h3 id="不可重复读" tabindex="-1"><a class="header-anchor" href="#不可重复读"><span>不可重复读</span></a></h3><h3 id="幻读" tabindex="-1"><a class="header-anchor" href="#幻读"><span>幻读</span></a></h3><p>事务A第一次查询id为1的数据，此时数据库没有id为1的数据。然后事务B向数据库插入了一条id为1的数据，此时事务A用之前相同的条件再次去查询id为1的数据，就会查询到id为1的数据，得到结果和第一次不同，这就是幻读。</p><p><strong>案例</strong></p><table><thead><tr><th style="text-align:left;">时间线</th><th style="text-align:left;">事务A</th><th style="text-align:left;">事务B</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:left;"><code>START TRANSACTION;</code></td><td style="text-align:left;"></td><td style="text-align:left;">事务A开始。</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;"><code>SELECT * FROM users WHERE age &gt; 22;</code> <br><strong>结果： (2, 李四, 25)</strong></td><td style="text-align:left;"></td><td style="text-align:left;"><strong>第一次查询</strong>。基于事务开始时的快照读，返回1条记录。</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:left;"></td><td style="text-align:left;"><code>START TRANSACTION;</code><br><code>INSERT INTO users (name, age) VALUES (&#39;王五&#39;, 30);</code><br><code>COMMIT;</code></td><td style="text-align:left;"><strong>事务B插入一条age=30的记录（满足age&gt;22）并提交。</strong> <br>这条新数据对于其他事务是立即可见的（已提交）。</td></tr><tr><td style="text-align:left;">4</td><td style="text-align:left;"><code>SELECT * FROM users WHERE age &gt; 22;</code> <br><strong>结果： (2, 李四, 25)</strong></td><td style="text-align:left;"></td><td style="text-align:left;"><strong>第二次快照读</strong> 。MVCC机制保证了可重复读，读取的是事务开始时的快照，<strong>看不到事务B新提交的“王五”</strong>。此时<strong>没有幻读</strong>。</td></tr><tr><td style="text-align:left;">5</td><td style="text-align:left;"><code>UPDATE users SET name = ‘测试’ WHERE age &gt; 22;</code> <br><code>Query OK, 2 rows affected</code></td><td style="text-align:left;"></td><td style="text-align:left;"><strong>关键步骤！</strong> 事务A执行了一个 <strong>当前读</strong> 的UPDATE操作。<br>这个操作会看到事务B提交的最新数据（即“王五”这条记录）。它发现有两行（李四和王五）满足条件，于是更新了<strong>两行</strong>。</td></tr><tr><td style="text-align:left;">6</td><td style="text-align:left;"><code>SELECT * FROM users WHERE age &gt; 22;</code> <br><strong>结果：<br>(2, ‘测试’, 25)<br>(3, ‘测试’, 30)</strong></td><td style="text-align:left;"></td><td style="text-align:left;"><strong>第三次查询</strong>。事务A再次查询。<br>由于上一步的UPDATE操作已经<strong>更新了这条新出现的幻影行</strong>，并且这个修改是属于事务A自身的，对自身总是可见的。<br>所以，这次查询 <strong>看到了两条记录</strong> ，这就是幻读。</td></tr><tr><td style="text-align:left;">7</td><td style="text-align:left;"><code>COMMIT;</code></td><td style="text-align:left;"></td><td style="text-align:left;">提交事务。</td></tr></tbody></table><hr><p><strong>总结：事务A读取到了事务B提交的新增数据，不符合事务的隔离性。</strong></p><h2 id="事务的四大隔离级别" tabindex="-1"><a class="header-anchor" href="#事务的四大隔离级别"><span>事务的四大隔离级别</span></a></h2><h3 id="_1-未提交读-read-uncommitted" tabindex="-1"><a class="header-anchor" href="#_1-未提交读-read-uncommitted"><span>1.未提交读(Read Uncommitted)</span></a></h3><p>允许脏读，也就是可能读取到其他事务中更新了，但是还没有提交的数据。</p><p>如果将读取到的未提交数据应用在业务逻辑中，而其他事务又回滚（rollback）了这个未提交的数据，那对系统来说就是个灾难。所以一般不适用该事务隔离级别。</p><h3 id="_2-读已提交-read-committed" tabindex="-1"><a class="header-anchor" href="#_2-读已提交-read-committed"><span>2.读已提交(Read Committed)</span></a></h3><p>也叫不可重复读。</p><p>只能读取到已经提交的数据。</p><h3 id="_3-可重复读-repeated-read" tabindex="-1"><a class="header-anchor" href="#_3-可重复读-repeated-read"><span>3.可重复读(Repeated Read)</span></a></h3>',24)),a("p",null,[s[4]||(s[4]=t("在同一个事务内，同一查询语句经过多次执行，得到的结果都会和事务第一次指定的查询结果保持一致，即使在这期间其他的事务对数据进行了修改（除非在本事务里也有进行一次update操作。（实现方式为MVCC《 ")),i(e,{to:"/database/104.MVCC%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%8F%90%E5%8D%87%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B3%E9%94%AE.html"},{default:n(()=>s[3]||(s[3]=[t("MVCC机制解析")])),_:1}),s[5]||(s[5]=t(" 》）"))]),a("p",null,[s[7]||(s[7]=t("在SQL标准中，这个隔离级别解决了不可重复读问题，但是还会存在幻读情况，但是InnoDB为了解决幻读引入的一种锁机制，叫间隙锁（参考 《")),i(e,{to:"/database/102.MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81.html#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Lock%EF%BC%89"},{default:n(()=>s[6]||(s[6]=[t("MySQL有间隙锁")])),_:1}),s[8]||(s[8]=t("》 ）。"))]),s[16]||(s[16]=l(`<blockquote><p>select操作是快照读（读的是MVCC日志版本链里的历史版本数据）</p><p>insert、update、delete是当前读（读取的数据是最新已提交数据）（同时会更新MVCC里的Read View一致性视图，所以在同一事务里，如果执行了insert、update、delete操作，则其后的select操作读取到的数据会是本次操作后的新数据。）</p><p>注意：所有update、delete操作都有行锁。</p></blockquote><h3 id="_4-串行读-serializable" tabindex="-1"><a class="header-anchor" href="#_4-串行读-serializable"><span>4.串行读(Serializable)</span></a></h3><p>完全串行化的读，每次读数据都需要获得表级共享锁，读写相互都会阻塞。是一种性能很低的隔离级别。</p><h3 id="隔离级别的选择" tabindex="-1"><a class="header-anchor" href="#隔离级别的选择"><span>隔离级别的选择</span></a></h3><p>先排除未提交读和串行读。</p><p>要求并发、和高性能场景使用读已提交，例如淘宝、饿了么这种直面用户的系统。</p><p>要求能获取到同一时间维度下，不变的数据，如拥有大量报表，后台数据管理系统之类的可以使用可重复读。</p><p>案例如下 《<a href="#%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E5%8A%A0%E4%BA%8B%E5%8A%A1%E5%90%97%EF%BC%9F">同一方法下多个查询同一时间（同一时刻）维度数据问题</a>》</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>幻读</th><th>不可重复读</th></tr></thead><tbody><tr><td>读未提交</td><td>存在</td><td>存在</td><td>存在</td></tr><tr><td>读已提交</td><td>不存在</td><td>存在</td><td>存在</td></tr><tr><td>可重复读</td><td>不存在</td><td><a href="#%E5%B9%BB%E8%AF%BB">存在</a></td><td>不存在</td></tr><tr><td>串行读</td><td>不存在</td><td>不存在</td><td>不存在</td></tr></tbody></table><h2 id="锁" tabindex="-1"><a class="header-anchor" href="#锁"><span>锁</span></a></h2><h3 id="读锁-共享锁" tabindex="-1"><a class="header-anchor" href="#读锁-共享锁"><span>读锁（共享锁）</span></a></h3><p>多个事务可以同时对同一资源添加共享锁，进行资源数据读取，但是不允许其他事务进行修改。</p><p>默认查询是不加锁的，可以手动使用如下命令进行加锁</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">from</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">table_name</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">lock</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">in</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">share</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">mode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="写锁-排它锁" tabindex="-1"><a class="header-anchor" href="#写锁-排它锁"><span>写锁（排它锁）</span></a></h3><p>一个资源被加了排它锁，就不能再被其他事务加排它锁或共享锁。</p><p>update、insert、delete都会加锁（排它锁）。</p><p>如果select操作想加排它锁，可使用如下命令</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">from</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">table_name</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">for</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">update</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="事务的优化" tabindex="-1"><a class="header-anchor" href="#事务的优化"><span>事务的优化</span></a></h2><h3 id="大事务的影响" tabindex="-1"><a class="header-anchor" href="#大事务的影响"><span>大事务的影响</span></a></h3><ul><li><p>回滚需要的时间长。</p></li><li><p>undolog日志急剧膨胀（这一个事务会生成大量的undo log日志）。</p></li><li><p>容易导致死锁。</p></li><li><p>大事务会锁定过多的数据，容易造成大量的阻塞和锁超时。</p></li><li><p>大事务会长时间占用数据库连接，在并发场景下，连接池资源容易被耗尽。</p></li></ul><h3 id="事务的优化-1" tabindex="-1"><a class="header-anchor" href="#事务的优化-1"><span>事务的优化</span></a></h3><ul><li><p>将查询等数据准备操作放到事务外</p></li><li><p>事务中避免远程调用，远程调用要设置超时，防止事务等待时间太久</p></li><li><p>事务中避免一次性处理太多数据，可以拆分成多个事务分次处理</p></li><li><p>更新等涉及加锁的操作尽可能放在事务靠后的位置（例如insert和update虽然都会加锁，但是因为insert是给新数据加的锁，基本上不会影响其他事务，update就不一样，加锁的资源，可能也有其他事务在等待访问）</p></li></ul><h2 id="常见问题" tabindex="-1"><a class="header-anchor" href="#常见问题"><span>常见问题</span></a></h2><h3 id="查询操作方法需要加事务吗" tabindex="-1"><a class="header-anchor" href="#查询操作方法需要加事务吗"><span>查询操作方法需要加事务吗？</span></a></h3><p>当一个方法里存在多个查询时，如果数据库事务隔离级别是可重复读，则建议添加事务，使用 <code>@Transaction(readOnly=true)</code> ，因为 <strong>可重复读的特性是，一次事务操作里，多次select的数据是不变的（除非在本事务里进行了更新操作）</strong> 。</p><p>如果不加事务，则达不到这个效果，例如</p><p>此时有两条数据，想要知道在 <strong>同一时刻的时间前提下</strong> ，张三和李四的余额谁多</p><table><thead><tr><th>id</th><th>名称name</th><th>余额balance</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>100</td></tr><tr><td>2</td><td>李四</td><td>200</td></tr></tbody></table><p>于是 <strong>事务A</strong> 先执行了</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">#</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">张三余额为100，此时此刻李四的余额应该是200</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">balance</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">from</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">table_name</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">where</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">id</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后当 <strong>事务A</strong> 在准备查询李四的余额时，另一个 <strong>事务B</strong> 更新了李四的余额</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">#</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">更新后李四的余额是300</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">update</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">table_name</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">set</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">balance</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">balance</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">where</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">id</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">2</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>于是此时 <strong>事务A</strong> 执行的SQL结果为</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">#</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">查询到的李四的余额为300</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">balance</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">from</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">table_name</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">where</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">id</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">2</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>此时事务A获取到的结果集就是（张三：100）、（李四：300）</p><p>但事务A想要的结果却是（张三：100）、（李四：200）</p><p>所以最终的比较是不符合预期的，也不符合给数据库设置的可重复读事务隔离级别特性。</p><p>所以建议在这类似的场景下添加 <code>@Transaction(readOnly=true)</code> 注解，就是给本次事务添加读锁。</p><h3 id="大事务查询与处理方式" tabindex="-1"><a class="header-anchor" href="#大事务查询与处理方式"><span>大事务查询与处理方式？</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">#</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">查询超过10秒的事务</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">from</span><span class="space"> </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">information_schema</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">innodb_trx</span><span class="space"> </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">where</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">time_to_sec(timediff(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">now</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">,</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">trx_started))</span><span class="space"> </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">#</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">释放锁，trx_mysql_thread_id可以从INNODB_TRX表里查看到</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">kill</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">trx_mysql_thread_id</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+c+'" alt="image-20250822215248772"></p>',44))])}const A=p(o,[["render",k],["__file","index.html.vue"]]),y=JSON.parse('{"path":"/interview/hnpv8hgq/","title":"MySQL的事务隔离级别和锁机制","lang":"zh-CN","frontmatter":{"title":"MySQL的事务隔离级别和锁机制","createTime":"2025/08/22 08:00:44","permalink":"/interview/hnpv8hgq/","tags":["数据库","MySQL","理论","事务","锁"],"description":"一组数据操作，要么全部成功，要么全部失败，目的是实现数据的一致性。 ​ ----事务 事务的隔离级别从高到低排序如下（高并发性能也是） 未提交读--->读已提交--->可重复读--->串行读 事务的ACID底层原理 事务的四大特性：原子性、一致性、隔离性、持久性 详细说明可参考《 》 并发场景下事务处理存在的问题 想学习了解事务的隔离级别，就需要先知道...","head":[["meta",{"property":"og:url","content":"https://blog.gaohan.asia/interview/hnpv8hgq/"}],["meta",{"property":"og:site_name","content":"云泽汇码"}],["meta",{"property":"og:title","content":"MySQL的事务隔离级别和锁机制"}],["meta",{"property":"og:description","content":"一组数据操作，要么全部成功，要么全部失败，目的是实现数据的一致性。 ​ ----事务 事务的隔离级别从高到低排序如下（高并发性能也是） 未提交读--->读已提交--->可重复读--->串行读 事务的ACID底层原理 事务的四大特性：原子性、一致性、隔离性、持久性 详细说明可参考《 》 并发场景下事务处理存在的问题 想学习了解事务的隔离级别，就需要先知道..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-24T15:44:21.000Z"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"理论"}],["meta",{"property":"article:tag","content":"事务"}],["meta",{"property":"article:tag","content":"锁"}],["meta",{"property":"article:modified_time","content":"2025-08-24T15:44:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL的事务隔离级别和锁机制\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-24T15:44:21.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":8.36,"words":2507},"git":{"updatedTime":1756050261000,"contributors":[{"name":"yunze","username":"yunze","email":"834363368@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"}]},"autoDesc":true,"filePathRelative":"notes/interview/1.MySQL/5.MySQL的事务隔离级别和锁机制.md"}');export{A as comp,y as data};
