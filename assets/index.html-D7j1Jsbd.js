import{_ as e,e as n,f as s,o as r}from"./app-Cx_oisp2.js";const o={};function l(a,t){return r(),n("div",null,t[0]||(t[0]=[s('<p><strong>20%的代码实现80%的需求，80%的代码处理20%的特殊场景。</strong></p><h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透"><span>缓存穿透</span></a></h2><blockquote><p><strong>查询一个根本不存在的数据</strong>，导致这个不存在的数据每次请求都无法命中缓存，请求直接穿透到数据库上。</p></blockquote><p>利用在缓存查询不到数据，再去mysql查询的机制（没有查询到数据直接返回），攻击者刻意制造不存在于mysql数据库数据的条件，去高频请求，将大量的请求直接穿过缓存，打向了数据库存储层。</p><h3 id="预防解决方案" tabindex="-1"><a class="header-anchor" href="#预防解决方案"><span>预防解决方案</span></a></h3><p><strong>缓存空数据</strong></p><p>从MySQL数据库查询数据为空时，也进行一次缓存，缓存空数据。</p><p><strong>加锁</strong></p><p>大量线程去数据库请求同一数据，可用互斥锁（RLock），缓存失效的情况，只有拿到锁才可以继续往下去查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。（加锁对系统的影响也就那么一瞬，只要数据从数据库里查询出来放到了缓存里，就能解决）</p><h2 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿"><span>缓存击穿</span></a></h2><blockquote><p><strong>某个热点key（访问量巨大）在缓存数据还不存在或过期的时间</strong>，同时有大量请求进来，导致所有请求都无法命中缓存，全部去访问数据库。</p></blockquote><ul><li><strong>比喻</strong>：一家超级网红店（热点key）休息时间（缓存过期）结束了，门口排着长队（大量请求）瞬间涌入，导致收银台（数据库）压力巨大。</li><li></li><li><strong>关键特征</strong>： <ol><li>数据在数据库中是<strong>存在的</strong>。</li><li>是一个<strong>热点key</strong>，并发访问量非常大。</li><li>缓存**恰好在这个时间点“失效”**了。</li></ol></li></ul><p><strong>危害</strong>：瞬间的巨大并发压力可能击垮数据库。</p><h3 id="预防解决方案-1" tabindex="-1"><a class="header-anchor" href="#预防解决方案-1"><span>预防解决方案</span></a></h3><p><strong>大量请求同时访问数据库？</strong></p><p>添加分布式互斥锁（RLock），当缓存失效时，不是所有线程都去查数据库，而是只让 <strong>一个线程</strong> 去查询数据库并重建缓存，其他线程等待并重试缓存查询。</p><h2 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩"><span>缓存雪崩</span></a></h2><blockquote><p><strong>大量的缓存key在同一时间点或时间段内失效</strong>，导致所有请求都落到了数据库上，引起数据库压力过大甚至宕机。</p></blockquote><p>大量请求超过redis服务可提供的荷载，导致缓存崩溃宕机等场景（或者突然大量缓存同时间到期删除），将请求压力导向了mysql数据存储层，导致mysql数据库服务压力陡增，从而不可用，然后因为mysql服务不可用，而导致web服务不可用，web服务a的不可用，又会导致业务有关联这个web a服务的其他服务不可用，最终导致扩展到整个系统不可用。</p><h3 id="预防解决方案-2" tabindex="-1"><a class="header-anchor" href="#预防解决方案-2"><span>预防解决方案</span></a></h3><p><strong>redis宕机了？</strong></p><p>要保证缓存的高可用，用 redis sentinel 和 redis cluster</p><p><strong>大量请求？</strong></p><p>增加请求限流熔断降级，用sentinel。</p><p><strong>缓存同时失效？</strong></p><p>不要设置相同的失效时间，失效时间上加上一个随机值，比如1-5分钟随机，避免了因为采用相同的过期时间导致的缓存雪崩。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">缓存穿透</th><th style="text-align:left;">缓存击穿</th><th style="text-align:left;">缓存雪崩</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>问题本质</strong></td><td style="text-align:left;">查询<strong>不存在</strong>的数据</td><td style="text-align:left;"><strong>单个热点key</strong>过期</td><td style="text-align:left;"><strong>大量key</strong>同时失效或<strong>缓存服务宕机</strong></td></tr><tr><td style="text-align:left;"><strong>缓存状态</strong></td><td style="text-align:left;">缓存和DB均<strong>无数据</strong></td><td style="text-align:left;">缓存<strong>刚好失效</strong>，DB有数据</td><td style="text-align:left;">缓存<strong>大规模失效</strong>，DB有数据</td></tr><tr><td style="text-align:left;"><strong>请求规模</strong></td><td style="text-align:left;">大量请求查询<strong>不同</strong>的不存在key</td><td style="text-align:left;">大量请求并发查询<strong>同一个</strong>key</td><td style="text-align:left;">大量请求查询<strong>很多不同的</strong>key</td></tr><tr><td style="text-align:left;"><strong>危害对象</strong></td><td style="text-align:left;">数据库</td><td style="text-align:left;">数据库</td><td style="text-align:left;">数据库 + 整个系统</td></tr><tr><td style="text-align:left;"><strong>解决方案</strong></td><td style="text-align:left;">1. 缓存空值<br>2. 布隆过滤器</td><td style="text-align:left;">1. 互斥锁<br>2. 逻辑过期<br>3. 永不过期</td><td style="text-align:left;">1. 错开过期时间<br>2. 高可用集群<br>3. 服务降级熔断</td></tr></tbody></table><p>简单记忆：</p><ul><li><strong>穿透</strong>：查无此物，恶意攻击。</li><li><strong>击穿</strong>：热点失效，万箭穿心。</li><li><strong>雪崩</strong>：集体失效，全面崩溃。</li></ul>',30)]))}const g=e(o,[["render",l],["__file","index.html.vue"]]),d=JSON.parse('{"path":"/interview/bxfe5izn/","title":"Redis缓存架构实战与优化","lang":"zh-CN","frontmatter":{"title":"Redis缓存架构实战与优化","createTime":"2025/08/30 17:23:22","permalink":"/interview/bxfe5izn/","description":"20%的代码实现80%的需求，80%的代码处理20%的特殊场景。 缓存穿透 查询一个根本不存在的数据，导致这个不存在的数据每次请求都无法命中缓存，请求直接穿透到数据库上。 利用在缓存查询不到数据，再去mysql查询的机制（没有查询到数据直接返回），攻击者刻意制造不存在于mysql数据库数据的条件，去高频请求，将大量的请求直接穿过缓存，打向了数据库存储层...","head":[["meta",{"property":"og:url","content":"https://blog.gaohan.asia/interview/bxfe5izn/"}],["meta",{"property":"og:site_name","content":"云泽汇码"}],["meta",{"property":"og:title","content":"Redis缓存架构实战与优化"}],["meta",{"property":"og:description","content":"20%的代码实现80%的需求，80%的代码处理20%的特殊场景。 缓存穿透 查询一个根本不存在的数据，导致这个不存在的数据每次请求都无法命中缓存，请求直接穿透到数据库上。 利用在缓存查询不到数据，再去mysql查询的机制（没有查询到数据直接返回），攻击者刻意制造不存在于mysql数据库数据的条件，去高频请求，将大量的请求直接穿过缓存，打向了数据库存储层..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-06T01:26:28.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-06T01:26:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis缓存架构实战与优化\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-06T01:26:28.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":3.56,"words":1067},"git":{"updatedTime":1757121988000,"contributors":[{"name":"yunze","username":"yunze","email":"834363368@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"}]},"autoDesc":true,"filePathRelative":"notes/interview/2.Redis/5.Redis缓存架构实战与优化.md"}');export{g as comp,d as data};
