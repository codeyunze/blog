import{_ as t,e as a,f as r,o as s}from"./app-Cx_oisp2.js";const n={};function o(i,e){return s(),a("div",null,e[0]||(e[0]=[r('<p>使用Redis缓存可以在极大程度上去缓解数据库的访问压力，但使用了Redis之后，就需要去保证缓存与数据库的数据一致性。</p><p>保证数据一致的方案有很多，列了延时双删、订阅更新机制、读写分离架构、通过binlog异步更新redis这几个推荐的方案，可根据实际情况具体选择。</p><h1 id="redis缓存与数据库数据一致性问题" tabindex="-1"><a class="header-anchor" href="#redis缓存与数据库数据一致性问题"><span>Redis缓存与数据库数据一致性问题</span></a></h1><h2 id="方案一-延时双删-推荐" tabindex="-1"><a class="header-anchor" href="#方案一-延时双删-推荐"><span>方案一：延时双删（推荐）</span></a></h2><p>在更新完db的数据之后，立马去删除一次redis的缓存，然后延时1~2秒，再去删除一次redis缓存。</p><p><strong>目的：</strong> 避免并发操作，导致缓存脏数据问题的出现。</p><p><strong>优点：</strong> 实现简单，可以有效解决大部分场景下的问题。即使第一次删除失败，第二次删除仍然有机会清除旧数据。</p><p><strong>缺点：</strong> 延时的时间不好确定。</p><h2 id="方案二-订阅更新机制" tabindex="-1"><a class="header-anchor" href="#方案二-订阅更新机制"><span>方案二：订阅更新机制</span></a></h2><p>在更新完db数据之后，立刻向 <code>消息队列</code> 发送一条删除缓存数据的消息，消费者监听到这个消息后，立刻去执行缓存删除操作。</p><p><strong>优点：</strong> 实时性好，缓存清理会非常及时。</p><p><strong>缺点：</strong> 实现相对复杂，消息队列要求可靠性，保证消息不会丢失，有一定维护成本。</p><h2 id="方案三-读写分离架构" tabindex="-1"><a class="header-anchor" href="#方案三-读写分离架构"><span>方案三：读写分离架构</span></a></h2><p>比较适合大数量流量，数据实时性要求不那么高的系统。</p><p>更新完db数据之后，由后台线程、定时任务、异步服务等方法去更新redis缓存数据，达到缓存和数据库数据的基本一致。</p><p><strong>优点：</strong> 缓存更新压力会降低很多。</p><p><strong>缺点：</strong> 实现复杂，需要做好异步的逻辑。</p><h2 id="方案四-通过binlog异步更新redis-推荐" tabindex="-1"><a class="header-anchor" href="#方案四-通过binlog异步更新redis-推荐"><span>方案四：通过binlog异步更新redis（推荐）</span></a></h2><p>更新完db数据之后，数据库的 <code>binlog</code> 日志文件里会有相关的操作记录，然后可以通过 <code> Cancel</code> 去监听并解析binlog日志，然后将解析的数据通过 <code>消息队列</code> 发送一条缓存更新消息，消费者监听到这个消息后去更新redis缓存数据。</p><p><strong>优点：</strong> 业务功能不会增加额外的代码，是扩展实现的。可以很好保证缓存与数据库数据的最终一致性。</p><p><strong>缺点：</strong> 有一定的维护成本，需要保证消息的消费顺序。</p>',21)]))}const d=t(n,[["render",o],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/database/opl5jkw9/","title":"Redis缓存与数据库数据一致性问题","lang":"zh-CN","frontmatter":{"title":"Redis缓存与数据库数据一致性问题","createTime":"2025/03/06 11:51:02","permalink":"/database/opl5jkw9/","tags":["redis","问题解决方案"],"description":"使用Redis缓存可以在极大程度上去缓解数据库的访问压力，但使用了Redis之后，就需要去保证缓存与数据库的数据一致性。 保证数据一致的方案有很多，列了延时双删、订阅更新机制、读写分离架构、通过binlog异步更新redis这几个推荐的方案，可根据实际情况具体选择。 Redis缓存与数据库数据一致性问题 方案一：延时双删（推荐） 在更新完db的数据之后...","head":[["meta",{"property":"og:url","content":"https://blog.gaohan.asia/database/opl5jkw9/"}],["meta",{"property":"og:site_name","content":"云泽汇码"}],["meta",{"property":"og:title","content":"Redis缓存与数据库数据一致性问题"}],["meta",{"property":"og:description","content":"使用Redis缓存可以在极大程度上去缓解数据库的访问压力，但使用了Redis之后，就需要去保证缓存与数据库的数据一致性。 保证数据一致的方案有很多，列了延时双删、订阅更新机制、读写分离架构、通过binlog异步更新redis这几个推荐的方案，可根据实际情况具体选择。 Redis缓存与数据库数据一致性问题 方案一：延时双删（推荐） 在更新完db的数据之后..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-31T15:43:01.000Z"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:tag","content":"问题解决方案"}],["meta",{"property":"article:modified_time","content":"2025-08-31T15:43:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis缓存与数据库数据一致性问题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-31T15:43:01.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":2.16,"words":648},"git":{"updatedTime":1756654981000,"contributors":[{"name":"yunze","username":"yunze","email":"56632502+YUNZE-GH@users.noreply.github.com","commits":3,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"},{"name":"yunze","username":"yunze","email":"834363368@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/yunze?v=4","url":"https://github.com/yunze"}]},"autoDesc":true,"filePathRelative":"database/125.Redis缓存与数据库数据一致性问题.md","categoryList":[{"id":"11e0ee","sort":10005,"name":"database"}]}');export{d as comp,c as data};
